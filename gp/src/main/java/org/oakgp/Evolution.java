/*
 * Copyright 2015 S. Webber
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http:
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.oakgp;

import jcog.pri.PLink;
import jcog.pri.bag.Bag;
import jcog.pri.bag.impl.PLinkArrayBag;
import jcog.pri.op.PriMerge;
import jcog.random.XoRoShiRo128PlusRandom;
import org.oakgp.evolve.GenerationEvolver;
import org.oakgp.evolve.GenerationEvolverImpl;
import org.oakgp.evolve.GeneticOperator;
import org.oakgp.evolve.crossover.SubtreeCrossover;
import org.oakgp.evolve.mutate.ConstantToFunctionMutation;
import org.oakgp.evolve.mutate.PointMutation;
import org.oakgp.evolve.mutate.SubTreeMutation;
import org.oakgp.function.Fn;
import org.oakgp.generate.TreeGenerator;
import org.oakgp.generate.TreeGeneratorImpl;
import org.oakgp.node.ConstantNode;
import org.oakgp.node.Node;
import org.oakgp.primitive.*;
import org.oakgp.rank.Evolved;
import org.oakgp.rank.GenerationRanker;
import org.oakgp.rank.Ranking;
import org.oakgp.rank.fitness.FitFn;
import org.oakgp.rank.fitness.FitnessRanker;
import org.oakgp.rank.tournament.RoundRobinTournamentRanker;
import org.oakgp.rank.tournament.TwoPlayerGame;
import org.oakgp.rank.tournament.TwoPlayerGameCache;
import org.oakgp.select.RankSelector;
import org.oakgp.terminate.CompositeTerminator;
import org.oakgp.terminate.MaxGenerationsTerminator;
import org.oakgp.terminate.MaxGenerationsWithoutImprovementTerminator;
import org.oakgp.terminate.TargetFitnessTerminator;
import org.oakgp.util.NodeSimplifier;

import java.util.*;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.logging.Logger;
import java.util.stream.Stream;

import static java.util.Objects.requireNonNull;
import static java.util.stream.Collectors.toList;

/**
 * Provides a convenient way to configure and start a genetic programming run.
 *
 * @see <a href="http:
 */
public final class Evolution {


    @Deprecated private static final double RATIO_VARIABLES = .6;
    private static final int DEFAULT_CACHE_SIZE = 32768;

    private NodeType _returnType;
    private Random rng = new XoRoShiRo128PlusRandom(System.nanoTime());
    private PrimitiveSet _primitiveSet;
    private GenerationRanker _generationRanker;
    private GenerationEvolver _generationEvolver;
    private Collection<Node> _initialPopulation;
    private Ranking population;

    /**
     * Performs a Genetic Programming run.
     *
     * @param eval  ranks a generation by their fitness
     * @param generationEvolver creates a new generation based on the previous generation
     * @param terminator        a function that determines if the run should finish
     * @param initialPopulation the initial population that will be used as a basis for generating future generations
     * @return the final generation produced as part of this run - the best candidate of this generation can be retrieved using {@link Ranking#top()}
     */
    public static Ranking process(Ranking population, GenerationRanker eval, GenerationEvolver generationEvolver, Predicate<Ranking> terminator,
                                  Stream<Node> initialPopulation) {
        eval.accept(initialPopulation, population);
        while (!terminator.test(population)) {
            eval.accept(generationEvolver.apply(population), population);
        }
        return population;
    }

    /**
     * Sets the required {@code Type} associated with the values produced as a result of evaluating the programs that are automatically generated by the run.
     */
    public RandomSetter returns(final NodeType returnType) {
        _returnType = requireNonNull(returnType);
        return new RandomSetter();
    }

    /**
     * Allows the function set to be configured.
     */
    public interface FnSetter {
        /**
         * Sets the functions that are available for use in the construction of programs generated by the run.
         */
        GenerationRankerSetter functions(Fn... functions);

        /**
         * Sets the functions that are available for use in the construction of programs generated by the run.
         */
        GenerationRankerSetter functions(List<Fn> functions);
    }

    /**
     * Provides a method for starting the genetic programming run or setting more termination criteria.
     */
    public interface TerminatorSetterOrProcessRunner extends TerminatorSetter, ProcessRunner {
    }

    /**
     * Allows termination criteria to be configured.
     */
    public interface TerminatorSetter extends MaxGenerationsTerminatorSetter {
        /**
         * Sets the criteria used by this run to determine when it should stop.
         */
        TerminatorSetterOrProcessRunner setTerminator(Predicate<Ranking> terminator);

        /**
         * Set the target fitness that when found should cause the run to stop.
         */
        MaxGenerationsTerminatorSetterOrProcessRunner stopFitness(double targetFitness);
    }

    /**
     * Provides a method for starting the genetic programming run or setting more termination criteria.
     */
    public interface MaxGenerationsTerminatorSetterOrProcessRunner extends MaxGenerationsTerminatorSetter, ProcessRunner {
    }

    /**
     * Allows termination criteria to be configured.
     */
    public interface MaxGenerationsTerminatorSetter extends MaxGenerationsWithoutImprovementTerminatorSetter {
        /**
         * Sets the maximum number of generations the run should process before stopping.
         */
        MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner stopGenerations(int maxGenerations);
    }

    /**
     * Provides a method for starting the genetic programming run or setting more termination criteria.
     */
    public interface MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner extends MaxGenerationsWithoutImprovementTerminatorSetter, ProcessRunner {
    }

    /**
     * Allows termination criteria to be configured.
     */
    public interface MaxGenerationsWithoutImprovementTerminatorSetter {
        /**
         * Sets the number of consecutive generations without improvement the run should process before stopping.
         */
        ProcessRunner setMaxGenerationsWithoutImprovement(int maxGenerationsWithoutImprovement);
    }

    /**
     * Provides a method for starting the genetic programming run.
     */
    public interface ProcessRunner extends Supplier<Ranking> {
        /**
         * Processes a genetic programming run using the values configured earlier for this {@code RunBuilder}.
         *
         * @return the final generation produced as part of this run - the best candidate of this generation can be retrieved using
         * {@link Ranking#top()}
         */

    }

    /**
     * Provides the option to set a random number generator, or to skip that option and instead configure the primitive setAt.
     * <p>
     * If you do not explicitly specify a random number generator then the {@code RunBuilder} will default to using {@link StdRandom}. Unless you
     * have a specific requirement about how random numbers are generated then the default random number generator will be sufficient.
     */
    public final class RandomSetter extends PrimitiveSetSetter {

        private RandomSetter() {
        }


        public PrimitiveSetSetter setRandom(final java.util.Random random) {
            rng = random;
            return this;
        }
    }

    /**
     * Allows the primitive set to be configured.
     */
    public class PrimitiveSetSetter {
        private PrimitiveSetSetter() {
        }

        /**
         * Sets the functions and terminal nodes that are available for use in the construction of programs generated by the run.
         */
        public GenerationRankerSetter setPrimitiveSet(final PrimitiveSet primitiveSet) {
            _primitiveSet = requireNonNull(primitiveSet);
            return new GenerationRankerSetter();
        }

        /**
         * Sets the constants that are available for use in the construction of programs generated by the run.
         */
        public VariablesSetter constants(final ConstantNode... constants) {
            return new VariablesSetter(NodeSet.byType(constants));
        }

        /**
         * Sets the constants that are available for use in the construction of programs generated by the run.
         */
        public VariablesSetter constants(final List<ConstantNode> constants) {
            return constants(constants.toArray(new ConstantNode[0]));
        }
    }

    /**
     * Allows the variable types to be configured.
     */
    public final class VariablesSetter {
        private final NodeSet<ConstantNode> constantSet;

        private VariablesSetter(final NodeSet<ConstantNode> constantSet) {
            this.constantSet = constantSet;
        }

        /**
         * Sets the {@code Type}s to associate with the variables available for use in the construction of programs generated by the run.
         */
        public VariablesRatioSetter variables(final NodeType... variableTypes) {
            return new VariablesRatioSetter(constantSet, VariableSet.of(variableTypes));
        }
    }

    /**
     * Allows the ratio of variables to constants to be configured.
     */
    public final class VariablesRatioSetter implements FnSetter {
        private final NodeSet constantSet;
        private final VariableSet variableSet;

        private VariablesRatioSetter(NodeSet constantSet, VariableSet variableSet) {
            this.constantSet = constantSet;
            this.variableSet = variableSet;
        }

        /**
         * Sets the ratio of terminal nodes that should be variable nodes, rather than constant nodes.
         *
         * @param ratioVariables a value in the range 0 to 1 (inclusive) which specifies the proportion of terminal nodes that should represent variables, rather than
         *                       constants
         * @throws IllegalArgumentException if {@code ratioVariables} is not in the range 0 to 1 inclusive
         */
        public FnSetter setRatioVariables(final double ratioVariables) {
            if (ratioVariables < 0 || ratioVariables > 1) {
                throw new IllegalArgumentException("Ratio of variables must be in range 0 to 1, not: " + ratioVariables);
            }
            return new FnSetterImpl(constantSet, variableSet, ratioVariables);
        }

        @Override
        public GenerationRankerSetter functions(Fn... functions) {
            return setRatioVariables(RATIO_VARIABLES).functions(functions);
        }

        @Override
        public GenerationRankerSetter functions(final List<Fn> functions) {
            return setRatioVariables(RATIO_VARIABLES).functions(functions);
        }
    }

    private final class FnSetterImpl implements FnSetter {
        private final NodeSet constantSet;
        private final VariableSet variableSet;
        private final double ratioVariables;

        private FnSetterImpl(NodeSet constantSet, VariableSet variableSet, double ratioVariables) {
            this.constantSet = constantSet;
            this.variableSet = variableSet;
            this.ratioVariables = ratioVariables;
        }

        @Override
        public GenerationRankerSetter functions(final Fn... functions) {
            

            FnSet functionSet = new FnSet(functions);
            _primitiveSet = new PrimitiveSetImpl(functionSet, constantSet, variableSet, rng, ratioVariables);
            return new GenerationRankerSetter();
        }

        @Override
        public GenerationRankerSetter functions(final List<Fn> functions) {
            return functions(functions.toArray(new Fn[0]));
        }


















    }

    /**
     * Allows the configuration of the mechanism for ranking candidates.
     */
    public final class GenerationRankerSetter {
        private GenerationRankerSetter() {
        }

        /**
         * Set the {@code GenerationRanker} used to rank and sort the candidates of a generation.
         */
        public InitialPopulationSetter ranked(final GenerationRanker generationRanker) {
            _generationRanker = requireNonNull(generationRanker);
            return new InitialPopulationSetter();
        }

        public InitialPopulationSetter goal(final FitFn fitnessFunction) {
            return goal(fitnessFunction, false);
        }

        /**
         * Set the {@code FitnessFunction} used to determine the fitness of a candidate.
         */
        public InitialPopulationSetter goal(final FitFn fitnessFunction, boolean parallel) {
            requireNonNull(fitnessFunction);
            FitFn cf = fitnessFunction;
            return ranked(
                parallel ? new FitnessRanker.Parallel(cf, DEFAULT_CACHE_SIZE) : new FitnessRanker.SingleThread(cf, DEFAULT_CACHE_SIZE)
            );
        }



        /**
         * Set the {@code TwoPlayerGame} used to determine the relative fitness of two candidates.
         */
        public InitialPopulationSetter setTwoPlayerGame(final TwoPlayerGame twoPlayerGame) {
            requireNonNull(twoPlayerGame);
            return ranked(new RoundRobinTournamentRanker(cached(twoPlayerGame)));
        }

        private TwoPlayerGame cached(final TwoPlayerGame twoPlayerGame) {
            if (twoPlayerGame instanceof TwoPlayerGameCache) {
                return twoPlayerGame;
            } else {
                return new TwoPlayerGameCache(DEFAULT_CACHE_SIZE, twoPlayerGame);
            }
        }
    }

    /**
     * Allows the initial population to be specified.
     */
    public final class InitialPopulationSetter {
        private InitialPopulationSetter() {
        }

        /**
         * Set the contents of the initial population.
         */
        public GenerationEvolverSetter setInitialPopulation(final java.util.function.Function<Config, Stream<Node>> initialPopulation) {
            return setInitialPopulation(initialPopulation.apply(new Config()));
        }

        /**
         * Set the contents of the initial population.
         */
        private GenerationEvolverSetter setInitialPopulation(Stream<Node> initialPopulation) {
            _initialPopulation = initialPopulation.collect(toList());
            return new GenerationEvolverSetter();
        }

        /**
         * Set the number of randomly generated trees to include in the initial population.
         */
        public TreeDepthSetter populationSize(int initialPopulationSize, final int totalPopulationSize) {
            population = new Ranking(totalPopulationSize);
            return new TreeDepthSetter(initialPopulationSize);
        }

        public TreeDepthSetter populationSize(int initialPopulationSize) {
            return populationSize(initialPopulationSize, initialPopulationSize);
        }
    }

    /**
     * Allows configuration of the maximum tree depth of trees randomly generated for the initial population.
     */
    public final class TreeDepthSetter {
        private final int generationSize;

        private TreeDepthSetter(final int generationSize) {
            this.generationSize = requiresPositive(generationSize);
        }

        /**
         * Set the maximum depth of the trees randomly generated for the initial population.
         */
        public GenerationEvolverSetter populationDepth(final int treeDepth) {
            requiresPositive(treeDepth);

            
            

            TreeGenerator treeGenerator = TreeGeneratorImpl.grow(_primitiveSet, rng);

            return new InitialPopulationSetter().setInitialPopulation(
                    Stream.generate(()->
                        NodeSimplifier.simplify( treeGenerator.generate(_returnType, treeDepth))
                    ).distinct().limit(generationSize)
            );

        }

        private int requiresPositive(final int i) {
            if (i > 0) {
                return i;
            } else {
                throw new IllegalArgumentException("Expected a positive integer but got: " + i);
            }
        }
    }

    /**
     * Provides the option to configure the how new generations evolve from existing ones, or to skip that option and instead configure the termination criteria.
     * <p>
     * If you do not explicitly specify how generations evolve then a default strategy will be used. The default strategy is sufficient for allowing people to
     * quickly get started with OakGP
     */
    public final class GenerationEvolverSetter extends FirstTerminatorSetter {
        private GenerationEvolverSetter() {
        }

        /**
         * Set how new generations will be created from existing ones.
         */
        public TerminatorSetter setGenerationEvolver(final java.util.function.Function<Config, GenerationEvolver> generationEvolver) {
            return setGenerationEvolver(generationEvolver.apply(new Config()));
        }

        /**
         * Set how new generations will be created from existing ones.
         */
        private TerminatorSetter setGenerationEvolver(GenerationEvolver generationEvolver) {
            _generationEvolver = requireNonNull(generationEvolver);
            return new FirstTerminatorSetter();
        }
    }

    private class FirstTerminatorSetter implements TerminatorSetter {
        private final List<Predicate<Ranking>> terminators = new ArrayList<>();

        private FirstTerminatorSetter() {
        }

        @Override
        public TerminatorSetterOrProcessRunner setTerminator(final Predicate<Ranking> terminator) {
            terminators.add(requireNonNull(terminator));
            return new SubsequentTerminatorSetter(terminators);
        }

        @Override
        public MaxGenerationsTerminatorSetterOrProcessRunner stopFitness(double targetFitness) {
            return new SubsequentTerminatorSetter(terminators).stopFitness(targetFitness);
        }

        @Override
        public MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner stopGenerations(final int maxGenerations) {
            return new MaxGenerationsTerminatorSetterImpl(terminators).stopGenerations(maxGenerations);
        }

        @Override
        public ProcessRunner setMaxGenerationsWithoutImprovement(int maxGenerationsWithoutImprovement) {
            return new MaxGenerationsWithoutImprovementTerminatorSetterImpl(terminators).setMaxGenerationsWithoutImprovement(maxGenerationsWithoutImprovement);
        }
    }

    private final class SubsequentTerminatorSetter extends MaxGenerationsTerminatorSetterImpl implements TerminatorSetterOrProcessRunner {
        private SubsequentTerminatorSetter(List<Predicate<Ranking>> terminators) {
            super(terminators);
        }

        @Override
        public TerminatorSetterOrProcessRunner setTerminator(final Predicate<Ranking> terminator) {
            terminators.add(terminator);
            return this;
        }

        @Override
        public MaxGenerationsTerminatorSetterOrProcessRunner stopFitness(double targetFitness) {
            terminators.add(new TargetFitnessTerminator(c -> Math.abs(c.pri() - targetFitness) < .0000001));
            return new MaxGenerationsTerminatorSetterImpl(terminators);
        }
    }

    private class MaxGenerationsTerminatorSetterImpl extends MaxGenerationsWithoutImprovementTerminatorSetterImpl implements
            MaxGenerationsTerminatorSetterOrProcessRunner {
        private MaxGenerationsTerminatorSetterImpl(List<Predicate<Ranking>> terminators) {
            super(terminators);
        }

        @Override
        public final MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner stopGenerations(int maxGenerations) {
            terminators.add(new MaxGenerationsTerminator(maxGenerations));
            return new MaxGenerationsWithoutImprovementTerminatorSetterImpl(terminators);
        }
    }

    private class MaxGenerationsWithoutImprovementTerminatorSetterImpl implements MaxGenerationsWithoutImprovementTerminatorSetterOrProcessRunner {
        protected final List<Predicate<Ranking>> terminators;

        private MaxGenerationsWithoutImprovementTerminatorSetterImpl(List<Predicate<Ranking>> terminators) {
            this.terminators = terminators;
        }

        @Override
        public final ProcessRunner setMaxGenerationsWithoutImprovement(int maxGenerationsWithoutImprovement) {
            terminators.add(new MaxGenerationsWithoutImprovementTerminator(maxGenerationsWithoutImprovement));
            return new ProcessRunnerImpl(terminators);
        }

        @Override
        public final Ranking get() {
            return new ProcessRunnerImpl(terminators).get();
        }
    }

    private final class ProcessRunnerImpl implements ProcessRunner {
        private final Predicate<Ranking> terminator;

        @SuppressWarnings("unchecked")
        private ProcessRunnerImpl(List<Predicate<Ranking>> terminators) {
            if (terminators.isEmpty()) {
                throw new IllegalStateException("No termination criteria setAt");
            } else if (terminators.size() == 1) {
                terminator = terminators.get(0);
            } else {
                terminator = new CompositeTerminator(terminators.toArray(new Predicate[0]));
            }
        }

        @Override
        public Ranking get() {
            if (_generationEvolver == null) {
                _generationEvolver = createDefaultGenerationEvolver();
            }

            _generationRanker.accept(_initialPopulation.stream(), population);

            Ranking rankedCandidates = process(population, _generationRanker, _generationEvolver, terminator, _initialPopulation.stream());
            Evolved best = rankedCandidates.top();
            Node simplifiedBestNode = (best.get());
            Logger.getGlobal().info("Best candidate: Fitness: " + best.pri() + " Structure: " + simplifiedBestNode);
            return rankedCandidates;
        }

        private GenerationEvolver createDefaultGenerationEvolver() {
            float elitism = 0.5f;
            Bag<org.oakgp.evolve.GeneticOperator, PLink<GeneticOperator>> operators = createDefaultGeneticOperators();
            return new GenerationEvolverImpl(elitism,
                    new RankSelector(rng),
                    operators, rng);
        }

        private Bag<org.oakgp.evolve.GeneticOperator, PLink<GeneticOperator>> createDefaultGeneticOperators() {
            Bag<org.oakgp.evolve.GeneticOperator, PLink<GeneticOperator>> operators = new PLinkArrayBag(PriMerge.plus, 10);


            TreeGenerator treeGenerator = TreeGeneratorImpl.grow(_primitiveSet, rng);
            operators.put(new PLink<>(t -> treeGenerator.generate(_returnType, 4), (.08f)));
            operators.put(new PLink<>(new SubtreeCrossover(rng, 5), (.4f)));
            operators.put(new PLink<>(new PointMutation(rng, _primitiveSet), (.4f)));
            operators.put(new PLink<>(new SubTreeMutation(rng, treeGenerator), (.04f)));
            operators.put(new PLink<>(new ConstantToFunctionMutation(rng, TreeGeneratorImpl.full(_primitiveSet)), (.04f)));
            return operators;
        }

        private int ratio(int whole, double ratio) {
            return (int) (whole * ratio);
        }
    }

    /**
     * Provides access to configuration values that have already been set on a {@code RunBuilder}.
     */
    public final class Config {
        public PrimitiveSet getPrimitiveSet() {
            return _primitiveSet;
        }

        public Random getRandom() {
            return rng;
        }

        public NodeType getReturnType() {
            return _returnType;
        }
    }

    public Evolution() {

    }

    public static RandomSetter of(NodeType returnType) {
        return new Evolution().returns(returnType);
    }
}
