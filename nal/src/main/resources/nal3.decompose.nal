//NAL3 single premise intersection decompose
    (M --> I), X, is(I,"&"), subOfPosOrNeg(I,X)   |-   (M --> withoutPosOrNeg(I,X)),   (Belief:StructuralDeduction,Goal:StructuralDeduction)
        //(M --> S), X, is(S,"&"), subOf(S,X)   |-          (M --> X), (Belief:StructuralDeduction,Goal:StructuralDeduction)
        //(M --> S), X, is(S,"&"), subOf(S,--X)   |-      --(M --> X), (Belief:StructuralDeduction,Goal:StructuralDeduction)

    (I --> M), X, is(I,"|"), subOfPosOrNeg(I,X)   |-   (withoutPosOrNeg(I,X)-->M), (Belief:StructuralDeduction,Goal:StructuralDeduction)
        //(S --> M), X, is(S,"|"), subOf(S,X)   |-         (X --> M), (Belief:StructuralDeduction,Goal:StructuralDeduction)
        //(S --> M), X, is(S,"|"), subOf(S,--X)   |-     --(X --> M), (Belief:StructuralDeduction,Goal:StructuralDeduction)

//NAL3 single premise union decompose
    (M --> U), X, is(U,"|"), subOfPosOrNeg(U,X)   |-    (M --> withoutPosOrNeg(U,X)), (Belief:StructuralDeductionWeak,Goal:StructuralDeductionWeak)
    (U --> M), X, is(U,"&"), subOfPosOrNeg(U,X)   |-    (withoutPosOrNeg(U,X) --> M), (Belief:StructuralDeductionWeak,Goal:StructuralDeductionWeak)


//decompose sect for a question/quest involving one component
    (A --> X), (S --> X), task("?@"), is(S,{"|","&"}), subOfPosOrNeg(S,A) |- (withoutPosOrNeg(S,A) --> X)
    (X --> A), (X --> S), task("?@"), is(S,{"|","&"}), subOfPosOrNeg(S,A) |- (X --> withoutPosOrNeg(S,A))

//        (M --> S), X, is(S,"&"), subOf(S,X)   |-    --(M --> X), (Belief:StructuralDeductionN,Goal:StructuralDeductionN)
//        (M --> S), X, is(S,"&"), subOf(S,--X)   |-    (M --> X), (Belief:StructuralDeductionN,Goal:StructuralDeductionN)
      //(M --> S), X, is(S,"|"), subOf(S,X)   |-      --(M --> X), (Belief:StructuralDeductionNN)
      //(M --> S), X, is(S,"|"), subOf(S,--X)   |-      (M --> X), (Belief:StructuralDeductionNN)
      //(M --> S), X, is(S,"&"), subOf(S,X)   |-  --(M --> X), (Belief:StructuralDeductionNN)
    //(M --> S), X, is(S,"&"), subOf(S,--X) |-    --(M --> X), (Belief:StructuralDeduction)
      //(M --> S), X, is(S,"&"), subOf(S,--X) |-    (M --> X), (Belief:StructuralDeductionNN)


//        (S --> M), X, is(S,"|"), subOf(S,X)   |-   --(X --> M), (Belief:StructuralDeductionN,Goal:StructuralDeductionN)
//        (S --> M), X, is(S,"|"), subOf(S,--X)   |-   (X --> M), (Belief:StructuralDeductionN,Goal:StructuralDeductionN)

      //(S --> M), X, is(S,"&"), subOf(S,X)   |-     --(X --> M), (Belief:StructuralDeductionNN)
      //(S --> M), X, is(S,"&"), subOf(S,--X)   |-     (X --> M), (Belief:StructuralDeductionNN)
      //(S --> M), X, is(S,"|"), subOf(S,X)   |- --(X --> M), (Belief:StructuralDeductionNN)
    //(S --> M), X, is(S,"|"), subOf(S,--X) |-   --(X --> M), (Belief:StructuralDeduction)
      //(S --> M), X, is(S,"|"), subOf(S,--X) |-   (X --> M), (Belief:StructuralDeductionNN)



//// inheritance decomposition ////////////////////////////////////////////////////////////////////////////////////
//if (S --> M) is the case, and ((|,S,A..+) --> M) is not the case, then ((|,A..+) --> M) is not the case, hence Belief:DecomposePositiveNegativeNegative

//(M --> S), (M --> (|,S,A_1..n)) |- (M --> (|,A_1..n)), (Truth:DecomposeNegativePositivePositive) = NP
     (M --> X), (M --> U), is(U,"|"), subOf(U,X)      |-   (M --> without(U,  X)), (Belief:DecomposeNP)
       (M --> X), (M --> U), is(U,"|"), subOf(U,--X)  |-   (M --> without(U,--X)), (Belief:DecomposePP)
     (M --> X), (M --> I), is(I,"&"), subOf(I,X)      |- --(M --> without(I,  X)), (Belief:DecomposePN)
        (M --> X), (M --> I), is(I,"&"), subOf(I,--X) |- --(M --> without(I,--X)), (Belief:DecomposeNN)
     (X --> M), (I --> M), is(I,"|"), subOf(I,X)      |- --(without(I,  X) --> M), (Belief:DecomposePN)
       (X --> M), (I --> M), is(I,"|"), subOf(I,--X)  |- --(without(I,--X) --> M), (Belief:DecomposeNN)
     (X --> M), (U --> M), is(U,"&"), subOf(U,X)      |-   (without(U,  X) --> M), (Belief:DecomposeNP)
      (X --> M), (U --> M), is(U,"&"), subOf(U,--X)   |-   (without(U,--X) --> M), (Belief:DecomposePP)

//       (M --> X), (M --> S), is(S,"|"), subOf(S,X) |- --(M --> without(S,X)), (Belief:DecomposePP)
       //(M --> X), (M --> S), is(S,"|"), subOf(S,--X)  |-  (M --> without(S,--X)), (Belief:DecomposeNN)

//(M --> S), (M --> (&,S,A_1..n)) |- (M --> (&,A_1..n)), (Truth:DecomposePositiveNegativeNegative) = --PN

//          //experimental unify
//          (M --> X), (N --> S), is(S,"&"), subOf(S,X), has(N,"#"),neq(M,N)   |- --unisubst((N --> without(S,X)), N, M), (Belief:DecomposePN)
     
        //TODO


//(S --> M), ((|,S,A_1..n) --> M) |- ((|,A_1..n) --> M), (Truth:DecomposePositiveNegativeNegative) = --PN

//           //experimental unify
//           (X --> M), (S --> N), is(S,"|"), subOf(S,X), has(N,"#"),neq(M,N)   |- --unisubst((without(S,X) --> N), N, M), (Belief:DecomposePN)

//(S --> M), ((&,S,A_1..n) --> M) |- ((&,A_1..n) --> M), (Truth:DecomposeNegativePositivePositive) = NP

//       (X --> M), (S --> M), is(S,"&"), subOf(S,--X) |- (without(S,--X) --> M), (Belief:DecomposePP)
//      (X --> M), (S --> M), is(S,"&"), subOf(S,X)   |- --(without(S,X) --> M), (Belief:DecomposePP)




 //intersection conditional goal decompose
 (S --> M), (X --> M), is(S,"|"), subOf(S,X) |- (without(S, X) --> M), (Goal:DecomposePP)
   (S --> M), (X --> M), is(S,"|"), subOf(S,X) |- --(without(S, X) --> M), (Goal:DecomposeNP)
   //(S --> M), (X --> M), is(S,"|"), subOf(S,--X) |- (without(S, --X) --> M), (Goal:DecomposePN)
 (S --> M), (X --> M), is(S,"&"), subOf(S,X) |- (without(S, X) --> M), (Goal:DecomposePN)
   //(S --> M), (X --> M), is(S,"&"), subOf(S,--X) |- (without(S, --X) --> M), (Goal:DecomposePP)
 (M --> S), (M --> X), is(S,"&"), subOf(S,X) |- (M --> without(S, X)), (Goal:DecomposePP)
   //(M --> S), (M --> X), is(S,"&"), subOf(S,--X) |- (M --> without(S, --X)), (Goal:DecomposePN)
 (M --> S), (M --> X), is(S,"|"), subOf(S,X) |- (without(S, X) --> M), (Goal:DecomposePN)
   //(M --> S), (M --> X), is(S,"|"), subOf(S,--X) |- (without(S, --X) --> M), (Goal:DecomposePP)


