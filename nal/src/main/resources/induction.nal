//General Induction and Temporal Induction
//  When P and then S happened according to an observation, by induction (weak) it may be that alyways after P, usually S happens.
//      According to reductions: For implications, the predicate may be allowed an implication, but not subject


//##################################

//belief form:
B, A, --is(A,"==>") |-          polarizeTask((polarizeBelief(A) ==> B)), (Belief:InductionDepolarized, Time:BeliefRelative)
B, A, --is(A,"==>") |- varIntro(polarizeTask((polarizeBelief(A) ==> B))), (Belief:InductionDepolarized, Time:BeliefRelative)

//question form:
//B, A, task("."), --is(A,"==>"), hasBelief() |-          polarizeTask((polarizeBelief(A) ==> B)), (Punctuation:Question, Time:BeliefRelative)
//B, A, task("."), --is(A,"==>"), hasBelief() |- varIntro(polarizeTask((polarizeBelief(A) ==> B))), (Punctuation:Question, Time:BeliefRelative)
        //B, A, --is(A,"==>") |- (--A ==> B), (Belief:InductionPN, Time:BeliefRelative, Also:VarIntro)




//##################################

//belief form:
B, A, --is(B,"==>") |-          polarizeBelief((polarizeTask(B) ==> A)), (Belief:AbductionDepolarized, Time:TaskRelative)
B, A, --is(B,"==>") |- varIntro(polarizeBelief((polarizeTask(B) ==> A))), (Belief:AbductionDepolarized, Time:TaskRelative)

//question form:
//B, A, task("."), --is(B,"==>"), hasBelief() |-          polarizeBelief((polarizeTask(B) ==> A)), (Punctuation:Question, Time:TaskRelative)
//B, A, task("."), --is(B,"==>"), hasBelief() |- varIntro(polarizeBelief((polarizeTask(B) ==> A))), (Punctuation:Question, Time:TaskRelative)

        //B, A, --is(B,"==>") |- (--B ==> A), (Belief:AbductionN, Time:TaskRelative, Also:VarIntro)




//##################################
//belief form:
B, A  |-          (polarizeTask(B) && polarizeBelief(A)), (Belief:IntersectionDepolarized, Time:Sequence)
B, A  |- varIntro((polarizeTask(B) && polarizeBelief(A))), (Belief:IntersectionDepolarized, Time:Sequence)

//question + quest form:
//B, A, --is(A,"==>"), --is(B,"==>"), task("."), hasBelief()  |-          (polarizeTask(B) && polarizeBelief(A)), (Punctuation:Question, Time:Sequence)
//B, A, --is(A,"==>"), --is(B,"==>"), task("."), hasBelief()  |- varIntro((polarizeTask(B) && polarizeBelief(A))), (Punctuation:Question, Time:Sequence)
    //B, A, --is(A,"==>"), --is(B,"==>")  |-          (polarizeTask(B) && polarizeBelief(A)), (Punctuation:AskAsk)
    //B, A, --is(A,"==>"), --is(B,"==>")  |- varIntro((polarizeTask(B) && polarizeBelief(A))), (Punctuation:AskAsk)

    //B, A, --is(A,"==>"), --is(B,"==>")  |- (polarizeTask(B) && polarizeBelief(A)), (Goal:IntersectionDepolarized, Time:Sequence)


    //(A==>B), (C==>D)     |- ((A && C) ==> (polarizeTask(B) && polarizeBelief(D))), (Belief:IntersectionDepolarized, Also:VarIntro)

      //B, A, --is(A,"==>"), --is(B,"==>"), --is(A,"&&"), --is(B,"&&")   |- (polarize(B,task) || polarize(A,belief)), (Belief:UnionDepolarized, Time:Relative, Also:VarIntro)

        //experiment
        //G, B, neq(G,B), task("!") |- (polarize(G, task) && polarize(B, belief)), (Goal:IntersectionDepolarized, Time:Relative)
          //G, B, neq(G,B), task("!") |- (--polarize(G, task) && polarize(B, belief)), (Goal:IntersectionDepolarized, Time:Relative)


    //B, A, neqOrInhCommon(A,B) |- (polarize(B,task) & polarize(A,belief)), (Belief:IntersectionDepolarized, Time:Intersect)
    //B, A, --has(A,"&&"), --has(B,"&&"), --has(A,"==>"), --has(B,"==>"), neqOrInhCommon(A,B) |- (polarize(B,task) ~ polarize(A,belief)), (Belief:DifferenceDepolarized, Time:Intersect)
    //B, A, --has(A,"&&"), --has(B,"&&"), --has(A,"==>"), --has(B,"==>"), neqOrInhCommon(A,B) |- (polarize(A,belief) ~ polarize(B,task)), (Belief:DifferenceReverseDepolarized, Time:Intersect)






//    B, A, --is(A,"~"), --is(B,"~"), --has(A,"&&"), --has(B,"&&"), --has(A,"==>"), --has(B,"==>"), neqRCom(A,B) |- (B ~ A), (Belief:Difference, Also:VarIntro)
//    B, A, --is(A,"~"), --is(B,"~"), --has(A,"&&"), --has(B,"&&"), --has(A,"==>"), --has(B,"==>"), neqRCom(A,B) |- (A ~ B), (Belief:DifferenceReverse, Also:VarIntro)

        //B, A, task("."), neqRCom(A,B)     |- (--,((--,polarize(B,task)) &&+- (--,polarize(A,belief)))), (Belief:UnionDepolarized)

        //B, A, task("."), time(dtEvents), --is(A,"==>"),--is(B,"==>")                            |- (B &&+- A), (Belief:Intersection)
        //B, A, task("."), neqAndCom(A,B),  --is(A,"==>"),--is(B,"==>")  |- varIntro((--,((--,polarize(B,task)) &&+- (--,polarize(A,belief))))), (Belief:UnionDepolarized)

        //B, A, task("."), time(dtEventsOrEternals), neqAndCom(A,B), --is(A,"==>"),--is(B,"==>")  |- varIntro((B &&+- A)), (Belief:Intersection)



//    B, A, task("."), time(dtEvents),                             --is(A,"==>"),--is(B,"==>") |- (A ==> B), (Belief:Induction)
//    B, A, task("."), time(dtEventsOrEternals), neqAndCom(A,B),     --is(A,"==>"),--is(B,"==>") |- varIntro((A ==> B)), (Belief:Induction)
//        B, A, task(negative), task("."), time(dtEvents),                          --is(A,"==>"),--is(B,"==>") |- ((--,%A) ==> B), (Belief:InductionN)
//        B, A, task(negative), task("."), time(dtEventsOrEternals), neqAndCom(A,B), --is(A,"==>"),--is(B,"==>") |- varIntro(((--,%A) ==> B)), (Belief:InductionN)

//    B, A, belief(positive), task("."), time(dtEvents),                                --is(B,"==>"),--is(A,"==>") |- (B ==> A), (Belief:Abduction)
//    B, A, belief(positive), task("."), time(dtEventsOrEternals), neqAndCom(A,B),       --is(A,"==>"),--is(B,"==>") |- varIntro((B ==> A)), (Belief:Abduction)
//        B, A, belief(negative), task("."), time(dtEvents),                            --is(B,"==>"),--is(A,"==>") |- ((--,%B) ==> A), (Belief:AbductionPN)
//        B, A, belief(negative), task("."), time(dtEventsOrEternals), neqAndCom(A,B),   --is(A,"==>"),--is(B,"==>") |- varIntro(((--,%B) ==> A)), (Belief:AbductionPN)




//NAL3 difference comparator

        //the hasNoDiffs constraint is not entirely necessary;
        //for now it is just meant to prevent derivations like:
        //  (tetris(5,13)~(((5,13)~(3,13))-->tetris)).



    //S || P: //should be covered more accurataely by the above cases
    //S, P, time(dtAfter), task("."), neqCom(P,S) |- (--,((--,%S) &&+- (--,%P))), (Belief:Union)
    //S, P, time(dtEventsOrEternals), task("."), neqAndCom(P,S) |- (--,varIntro(((--,%S) &&+- (--,%P)))), (Belief:Union)


//backward temporal induction
//    (A ==> B), A, time(decomposeTask), task("?") |- B, (Punctuation:Question)
//    ((--,%A) ==> B), A, time(decomposeTask), task("?") |- B, (Punctuation:Question)
//    (A ==> B), B, time(decomposeTask), task("?") |- A, (Punctuation:Question)
    //(A <=> B), A, time(decomposeTask), task("?") |- B, (Punctuation:Question)
