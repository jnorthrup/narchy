//conjunction/disjunction structural decomposition



    //free structural Conjunction/Disjunction decomposition
    C, X, eventOfPN(C,X), task("?@"), hasBelief()   |-   conjWithoutPN(C,X)
    C, X, eventOfPN(C,X)                            |-   conjWithoutPN(C,X), (Belief:StructuralDeduction, Goal:StructuralDeduction)
    D, X, eventOfPN(D,X)                            |- --conjWithoutPN(D,X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)
//    D, X, eventOfPN(D,X)                            |- --conjWithoutPN(D,X), (Belief:StructuralDeductionN, Goal:StructuralDeductionN)
//    D, X, eventOfPN(D,X)                            |-   conjWithoutPN(D,X), (Belief:StructuralDeductionWeak, Goal:StructuralDeductionWeak)

    //impl conj/disj pred belief and question free structural implication decomposition
    (A ==> C), X, eventOfPN(C,X), --isVar(A)   |-   (A ==> conjWithoutPN(C,  X)), (Belief:StructuralDeduction)
      (A ==> D), X, eventOfPN(D,X), --isVar(A)   |-   (A ==> --conjWithoutPN(D,  X)), (Belief:StructuralDeductionWeakN)
    //(A ==> C), X, eventOfPN(C,X), --isVar(A)   |-   polarizeTask((A ==> conjWithoutPN(C,  X))), (Belief:StructuralDeductionDepolarized)

         (A ==> C), X, eventOfPN(C,X), task("?"), --isVar(A)   |- (A ==> conjWithoutPN(C,  X)), (Punctuation:Question)
         (A ==> C), C, task("?")   |- C, (Punctuation:Question)

    //impl conj subj belief and question free structural implication decomposition
    (  C ==> A), X, eventOfPN(C,X), --isVar(A)   |- polarizeTask((  conjWithoutPN(C,    X) ==> A)), (Belief:StructuralDeductionWeakDepolarized)
      (  --D ==> A), X, eventOfPN(D,X), --isVar(A) |- polarizeTask((  --conjWithoutPN(D,    X) ==> A)), (Belief:StructuralDeductionDepolarized)
       //(  C ==> A), X, eventOfPN(C,X), --isVar(A)   |- polarizeTask((  conjWithoutPN(C,    X) ==> A)), (Belief:StructuralReductionDepolarized)

        (C ==> A), X, eventOfPN(C,X), task("?"), --isVar(A)   |- (conjWithoutPN(C,  X) ==> A), (Punctuation:Question)
        (C ==> A), E, task("?")   |- C, (Punctuation:Question)

    //impl disj subj belief and question free structural implication decomposition
    //(--D ==> A), X, eventOfPN(D,X), --isVar(A)   |- polarizeTask((--conjWithoutPN(D,  --X) ==> A)), (Belief:StructuralReductionDepolarized)

        (--D ==> A), X, eventOfPN(D,X), task("?"), --isVar(A)   |- (--conjWithoutPN(D,  --X) ==> A), (Punctuation:Question)
        (--D ==> A), D, task("?")   |- D, (Punctuation:Question)





//    //goal/antigoal in sequence
//    X, C, eventOf(C,X), --eventOfNeg(C,X)   |- C, (Goal:DesireWeak, Time:BeliefAtTask)
//      //X, C, eventOfNeg(C,X), --eventOf(C,X)   |- --C, (Goal:Deduction, Time:BeliefAtTask)
//    X, C, eventOfNeg(C,X), --eventOf(C,X)   |- C, (Goal:DesireWeakN, Time:BeliefAtTask)
//      //X, C, eventOf(C,X), --eventOfNeg(C,X)   |- --C, (Goal:DeductionN, Time:BeliefAtTask)

    //X, C, eventOfNeg(C,X) |- --conjWithout(C,--X), (Goal:DesireWeak, Time:BeliefSubSequence)
    //X, C, eventOf(C,X)    |- --conjWithout(C,X), (Goal:DesireWeakN, Time:BeliefSubSequence)


    //see: https://en.wikipedia.org/wiki/Imperative_logic#Ross.27_Paradox


    //X is the desired event suffix (outcome).
    //C is a sequence ending in it.  this forms a goal of the sequence minus the trailing

    //desire for sub-sequence leading to goal,  truth function may be Desire or Deduction
    G, C, is(C,"&&")                  |-      conjBefore(C,   G),  (Goal:DesirePP)
    G, C, is(C,"&&"), has(C,"--")     |-      conjBefore(C, --G),  (Goal:DesireNP)

//probably wrong:
//      G, D, is(D,"&&"), has(D,"--")   |-    --conjBefore(D, --G),  (Goal:DesireWeakPN)
//      G, D, is(D,"&&")                |-    --conjBefore(D,   G),  (Goal:DesireWeakNN)

            //--eventOfNeg(C,G) , --eventOf(C,G) <- optional additional renovelion of anti-goal not present anywhere in the sequence

    //anti-desire for sub-sequence leading to anti-goal. truth function may be Desire or Deduction (option: __Weak, __WeakN)
    G, C, is(C,"&&"), has(C,"--")       |-              --conjBefore(C, --G),  (Goal:Desire)
    G, C, is(C,"&&")                    |-              --conjBefore(C,   G),  (Goal:DesireN)
      //G, C, is(C,"&&"), has(C,"--")     |-   negateEvents(conjBefore(C, --G)), (Goal:DesireWeak)
      //G, C, is(C,"&&")                  |-   negateEvents(conjBefore(C,   G)), (Goal:DesireWeakN)

    //conjunction belief decomposition
    C, X, is(C,"&&"), --isVar(X)                   |-   conjAfter(C,  X), (Belief:DeductionPP,Goal:DeductionPP)
//      D, X, is(D,"&&"), has(D,"--"), --isVar(X)    |- --conjAfter(D,--X), (Belief:DeductionWeakPP,Goal:DeductionWeakNP)
    C, X, is(C,"&&"), has(C,"--"), --isVar(X)      |-   conjAfter(C,--X), (Belief:DeductionPN,Goal:DeductionPN)
//      D, X, is(D,"&&"), --isVar(X)                 |- --conjAfter(D,  X), (Belief:DeductionWeakPN,Goal:DeductionWeakNN)
//
//    //conjunction goal decomposition
//    G, C, is(C,"&&")                   |-   conjAfter(C,  G), (Goal:DesirePP)
//      G, D, is(D,"&&")                 |- --conjAfter(D,--G), (Goal:DesirePN)
//    G, C, is(C,"&&"), has(C,"--")      |-   conjAfter(C,--G), (Goal:DesireWeakNP)
//      G, D, is(D,"&&")                 |- --conjAfter(D,  G), (Goal:DesireWeakNN)

//      (C==>A), (X==>A), is(C,"&&"), --isVar(X)     |- (conjAfter(C,  X) ==> A), (Belief:Deduction)
//      (C==>A), (X==>A), is(C,"&&"), --isVar(X)     |- (conjAfter(C,  X) ==> A), (Belief:DeductionNN)
      //(A==>C), (A==>X), is(C,"&&"), --isVar(X)     |- (A ==> conjAfter(C,  X)), (Belief:Deduction)
      //(A==>C), (A==>X), is(C,"&&"), --isVar(X)     |- (A ==> conjAfter(C,--X)), (Belief:DeductionPN)
      //(A==>C), (A==>X), is(C,"&&"), --isVar(X)     |- (A ==> conjAfter(C,  X)), (Belief:DeductionNN)


    //TODO nal3 shortcut - decompose trailing intersection/union event


        //TODO chooseUnifiableSubterm
          B, (   (&&,  C,A..+) ==> X), --isVar(C)     |- unisubst((&&,polarizeBelief(X),       A..+ ),C,polarizeTask(B)), (Belief:DeductionDepolarized)
          B, ( --(&&,--C,A..+) ==> X), --isVar(C)     |- unisubst((&&,polarizeBelief(X),       A..+ ),C,polarizeTask(B)), (Belief:DeductionDepolarized)

//          B, (--(&&,C,A..+) ==> X)     |- unisubst((&&,polarizeBelief(X), --(&&,A..+)),C,polarizeTask(B)), (Belief:DeductionDepolarized)
//          B, ((&&,--C,A..+) ==> X)       |- unisubst((&&,--X,A..+),C,B), (Belief:DeductionNN, Goal:DesireNN)
//              B, (--(&&,C,A..+) ==> X)   |- unisubst(--(&&,--X,A..+),C,B), (Belief:DeductionPN, Goal:DesirePN)
//              B, (--(&&,--C,A..+) ==> X) |- unisubst(--(&&,--X,A..+),C,B), (Belief:DeductionNN, Goal:DesireNN)


//Anonymous Deduction and Abduction
    X, (V ==> X), task("?"), is(V,"#"), --isVar(X)      |- X, (Belief:BeliefStructuralReduction)
    X, (--V ==> X), task("?"), is(V,"#"), --isVar(X)    |- X, (Belief:BeliefStructuralReduction)

        X, (X ==> V), task("?"), is(V,"#"), --isVar(X)      |- X,   (Belief:BeliefStructuralAbduction)
        X, (--X ==> V), task("?"), is(V,"#"), --isVar(X)    |- --X, (Belief:BeliefStructuralAbduction)

//    //conditional goal disjunction decompose (alternate suppress by goal)
//    G, D, sectOf(D,G), conjParallel(D)      |- --unsect(D,  G), (Goal:DesireWeakPN)
//    G, D, sectOf(D,--G), conjParallel(D)   |- --unsect(D,--G), (Goal:DesireWeakNN)

//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case
// TODO these could be merged with NAL3 decompositions into a general decomposition rule

    //CONJ
    X, C, sectOf(C,X), conjParallel(C)     |-     unsect(C,  X), (Belief:DecomposePP)
     C, X, sectOf(C,X), conjParallel(C)     |-     unsect(C,  X), (Belief:DecomposePP, Goal:DecomposePP)
    X, C, sectOf(C,X), conjParallel(C)     |-   --unsect(C,  X), (Belief:DecomposePN)
     C, X, sectOf(C,X), conjParallel(C)     |-   --unsect(C,  X), (Belief:DecomposeNP, Goal:DecomposeNP)
    X, C, sectOf(C,--X), conjParallel(C)  |-     unsect(C,--X), (Belief:DecomposeNP)
     C, X, sectOf(C,--X), conjParallel(C)  |-     unsect(C,--X), (Belief:DecomposePN, Goal:DecomposePN)
    X, C, sectOf(C,--X), conjParallel(C)  |-   --unsect(C,--X), (Belief:DecomposeNN)
     C, X, sectOf(C,--X), conjParallel(C)  |-   --unsect(C,--X), (Belief:DecomposeNN, Goal:DecomposeNN)


    //this should be handled by the decompose above:
    //conditional goal disjunction decompose (alternate suppress by belief)
    //D, X, sectOf(D,X), conjParallel(D)      |-   --unsect(D,  X), (Goal:DeductionWeakNP)
    //D, X, sectOf(D,--X), conjParallel(D)   |-   --unsect(D,--X), (Goal:DeductionWeakNN)


//Conditional implication decomposition
//  Original:
//    (S ==> M), ((&&,S,A_1..n) ==> M) |- ((&&,A_1..n) ==> M), (Truth:DecomposeNegativePositivePositive, Order:ForAllSame, SequenceIntervals:FromBelief)
//    (S ==> M), ((||,S,A_1..n) ==> M) |- ((||,A_1..n) ==> M), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame)
//    (M ==> S), (M ==> (&&,S,A_1..n)) |- (M ==> (&&,A_1..n)), (Truth:DecomposePositiveNegativeNegative, Order:ForAllSame, SequenceIntervals:FromBelief)
//    (M ==> S), (M ==> (||,S,A_1..n)) |- (M ==> (||,A_1..n)), (Truth:DecomposeNegativePositivePositive, Order:ForAllSame)


    //conj
    (  S ==> M), (C ==> M), eventOf(C,S)                |-      (  conjWithout(C, S) ==> M), (Belief:DecomposePP)
     (  S ==> M), (C ==> M), eventOf(C,S)                |-   --(  conjWithout(C, S) ==> M), (Belief:DecomposeNN)
       (  --S ==> M), (C ==> M), eventOfNeg(C,S)         |-   (  conjWithout(C, --S) ==> M), (Belief:DecomposePP)
         ( --S ==> M), (C ==> M), eventOfNeg(C,S)       |- --(  conjWithout(C, --S) ==> M), (Belief:DecomposeNN)

    //disj
    (  S ==> M), (--C ==> M), eventOfNeg(C,S)              |-  (  --conjWithout(C, --S) ==> M), (Belief:DecomposeNP)
       ( S ==> M), (--C ==> M), eventOfNeg(C,S)            |- --(  --conjWithout(C, --S) ==> M), (Belief:DecomposePN)
           ( --S ==> M), (--C ==> M), eventOf(C,S)     |-   (  --conjWithout(C, S) ==> M), (Belief:DecomposeNP)
        (  --S ==> M), (--C ==> M), eventOf(C,S)       |- --(  --conjWithout(C, S) ==> M), (Belief:DecomposePN)

//conj pred
    (M ==> S), (M ==> C), eventOf(C,S)                  |- --(M ==> conjWithout(C,   S)), (Belief:DecomposePN)
    (M ==> S), (M ==> C), eventOfNeg(C,S)               |- --(M ==> conjWithout(C, --S)), (Belief:DecomposeNN)
     (M ==> S), (M ==> C), eventOf(C,S)                 |-   (M ==> conjWithout(C,   S)), (Belief:DecomposePP)
     (M ==> S), (M ==> C), eventOfNeg(C,S)              |-   (M ==> conjWithout(C, --S)), (Belief:DecomposeNP)



//Anonymous Analogy (NAL5)
//  originally this only unified depvar (dep var elimination)

//TODO merge these 4 rules into one, requires a variation on unisubst that can apply chooseUnifiableSubEvent in 2 ways
C, Y, is(C,"&&"), has(C,"#"), neq(C,Y), --isVar(Y)               |- unisubst(C,chooseUnifiableSubEvent(C,Y),Y,"#",novel), (Belief:AnonymousAnalogy)
C, Y, is(C,"&&"), has(C,"#"), neq(C,Y), --isVar(Y), has(C,"--")  |- unisubst(C,chooseUnifiableSubEvent(C,--Y),--Y,"#",novel), (Belief:AnonymousAnalogyPN)
    //Goal: ?

    //(&&,X,A..+), Y   |- unisubst((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogy)
      //accelerated version requiring no second-level unification and allows the general case unisubst to be 'novel'
      //C, X, eventOf(C,X)    |- conjWithout(C,X), (Belief:AnonymousAnalogy)
    //(&&,--X,A..+), Y   |- unisubst((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogyPN)
      //accelerated version requiring no second-level unification and allows the general case unisubst to be 'novel'
      //C, X, eventOfNeg(C,X) |- conjWithout(C,--X), (Belief:AnonymousAnalogyPN)

//    Y, (&&,X,A..+)                  |- unisubst((&&,  X,A..+),X,Y,"#",novel), (Belief:Deduction)
//    Y, (&&,--X,A..+)                |- unisubst((&&,--X,A..+),X,Y,"#",novel), (Belief:DeductionN)
//        Y, (&&,X,A..+), task("?")       |- unisubst((&&,  X,A..+),X,Y,"#",novel), (Punctuation:Question)
//        Y, (&&,--X,A..+), task("?")     |- unisubst((&&,--X,A..+),X,Y,"#",novel), (Punctuation:Question)
//        Y, (&&,X,A..+), task("@")       |- unisubst((&&,  X,A..+),X,Y,"#",novel), (Punctuation:Quest)
//        Y, (&&,--X,A..+), task("@")     |- unisubst((&&,--X,A..+),X,Y,"#",novel), (Punctuation:Quest)


          //Disjunction structural decompose: D = (||,a,b,..) = --(&&,--a, --b, ..)
          //   disabled: may be spam-like
            //D, X,conjParallel(D),  eventOfNeg(D,X)  |- --conjWithout(D,--X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)
            //D, X,conjParallel(D),  eventOf(D,X)     |- --conjWithout(D,X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)

    //D, X, --is(X,"#"),                     eventOf(D,X)     |- --X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),conjParallel(D), eventOf(D,X)     |- --X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),                     eventOfNeg(D,X)  |-   X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventNeg)
    //D, X, --is(X,"#"),conjParallel(D), eventOfNeg(D,X)  |-   X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventNeg)

//    //specific deduction
//    C, X, eventOf(C,X)           |-   conjWithout(C,  X), (Belief:DeductionPP)
//    C, X, eventOfNeg(C,X)        |-   conjWithout(C,--X), (Belief:DeductionPN)
//        //anti-specific deduction: "conjunction contraposition" (weak)
//        C, X, eventOf(C,X)       |-   negateEvents(conjWithout(C,  X)), (Belief:DeductionWeakPN)
//        C, X, eventOfNeg(C,X)    |-   negateEvents(conjWithout(C,--X)), (Belief:DeductionWeakPP)
