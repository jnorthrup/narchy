//conjunction/disjunction structural decomposition
//   see: https://en.wikipedia.org/wiki/Imperative_logic#Ross.27_Paradox

Y, C, neq(Y,C), is(C,"&&"), --isVar(Y)                |- unisubst(C,chooseUnifiableSubEvent(C,Y),Y), (Belief:Deduction, Time:TaskEvent)
  Y, C, neq(Y,C), is(C,"&&"), --isVar(Y), has(C,"--") |- unisubst(C,chooseUnifiableSubEvent(C,--Y),--Y), (Belief:DeductionN, Time:TaskEvent)
//Y, (&&,X,A..+), neq(X,Y) |- unisubst((&&,A..+),X,Y), (Belief:Deduction, Time:TaskEvent)
// Y, (&&,--X,A..+), neq(X,Y) |- unisubst((&&,A..+), X,Y), (Belief:DeductionN, Time:TaskEvent)

//free structural Conjunction/Disjunction decomposition
C, X,  conjParallel(C), eventOfPN(C,X)   |-   conjWithoutPN(C,X), (Belief:StructuralDeduction, Time:TaskEvent)
  C, X, conjParallel(C), eventOfPN(C,X)  |-   conjWithoutPN(C,X), (Goal:StructuralDeduction, Time:TaskEvent)

C, X, eventOfPN(C,X)      |-   conjWithoutPN(C,X), (Punctuation:AskAsk)

  C, X, --isVar(X), hasBelief(), conjSequence(C) |- conjBefore(C,  polarizeBelief(X)), (Punctuation:AskAsk, Time:BeliefEvent)
  C, X, --isVar(X), hasBelief(), conjSequence(C) |- conjAfter(C,  polarizeBelief(X)), (Punctuation:AskAsk, Time:BeliefEvent)


    //question short-circuit answer
    C, X, task("?"), eventOf(C,X)    |- --C,  (Belief:BeliefStructuralDeductionPN, Punctuation:Belief, Time:TaskEvent)
    C, X, task("?"), eventOfNeg(C,X) |-   C,  (Belief:BeliefStructuralDeductionPP, Punctuation:Belief, Time:TaskEvent)
        //TODO other short-circuits, involving ==> etc


    //impl conj/disj pred belief and question free structural implication decomposition
    (A ==> C), X, eventOfPN(C,X), --isVar(X)   |-   (A ==> conjWithoutPN(C,  X)), (Belief:StructuralDeduction, Time:Task)

      (A ==> D), X, conjParallel(D), eventOf(D,X), --isVar(X)      |-   (A ==>   X), (Belief:StructuralDeductionN, Time:Task)
      (A ==> D), X, conjParallel(D), eventOfNeg(D,X), --isVar(X)   |-   (A ==> --X), (Belief:StructuralDeductionN, Time:Task)


        //(A ==> C), X, eventOfPN(C,X)   |-   (A ==> conjWithoutPN(C,  X)), (Belief:StructuralDeduction)
          //(A ==> D), X, eventOfPN(D,X)   |-   (A ==> --conjWithoutPN(D,  X)), (Belief:StructuralDeductionWeakN)
        //(A ==> C), X, eventOfPN(C,X)   |-   polarizeTask((A ==> conjWithoutPN(C,  X))), (Belief:StructuralDeductionDepolarized)

         (A ==> C), X,  eventOfPN(C,X), task("?"), --isVar(X)   |- (A ==> conjWithoutPN(C,  X)), (Punctuation:Question, Time:Task)


//    //impl conj subj belief and question free structural implication decomposition
    //(  C ==> A), X,  eventOfPN(C,X), --isVar(X)   |- polarizeTask((  conjWithoutPN(C,    X) ==> A)), (Belief:StructuralDeductionDepolarized)
      //(  --D ==> A), X, conjParallel(D), eventOfNeg(D,X), --isVar(X) |- polarizeTask((  X ==> A)), (Belief:StructuralDeductionDepolarized)
      //(  --D ==> A), X, conjParallel(D), eventOf(D,X), --isVar(X) |- polarizeTask((  --X ==> A)), (Belief:StructuralDeductionDepolarized)
//
        (  C ==> A), X, eventOfPN(C,X), task("?"), --isVar(X)   |- (  conjWithoutPN(C,  X) ==> A), (Punctuation:Question, Time:Task)
//          (  --D ==> A), X, conjParallel(D), eventOfNeg(D,X), task("?"), --isVar(X) |- (  X ==> A), (Punctuation:Question)
//          (  --D ==> A), X, conjParallel(D), eventOf(D,X), task("?"), --isVar(X)    |- (--X ==> A), (Punctuation:Question)

        //(A ==> C), (A ==> C), task("?"), --isVar(C)                 |- C, (Punctuation:Question)
        //(C ==> A), (C ==> A), task("?"), --isVar(C), --eqPN(A,C)    |- C, (Punctuation:Question)





    (B ==> (&&,X,A..+)), Y, --isVar(X),--isVar(Y), hasBelief()  |- polarizeTask(unisubst((B ==> (&&,X,A..+)),X,polarizeBelief(Y)),novel), (Belief:DeductionDepolarized, Time:BeliefEvent, Time:Task)
    ((&&,X,A..+) ==> B), Y, --isVar(X),--isVar(Y), hasBelief()  |- polarizeTask(unisubst(((&&,X,A..+) ==> B),X,polarizeBelief(Y)),novel), (Belief:DeductionDepolarized, Time:BeliefEvent, Time:Task)
      //(B ==> (&&,X,A..+)), Y, --isVar(X),--isVar(Y)  |- polarizeTask(unisubst((B ==> (&&,A..+)),X,polarizeBelief(Y))), (Belief:DeductionDepolarized, Time:BeliefEvent)
      //((&&,X,A..+) ==> B), Y, --isVar(X),--isVar(Y)  |- polarizeTask(unisubst(((&&,A..+) ==> B),X,polarizeBelief(Y))), (Belief:DeductionDepolarized, Time:BeliefEvent)



    //sub-sequence following belief or goal
    //(&/,B,A_1..n), B, task("!") |- (&/,A_1..n), (Truth:Deduction, Desire:Strong, SequenceIntervals:FromPremises)
    C, X, --isVar(X)                    |-     conjAfter(C,   X),     (Belief:DeductionPP, Time:BeliefEvent)
      C, X, --isVar(X)                  |-     conjAfter(C,   X),       (Goal:DeductionPP, Time:TaskEvent)
    C, X, --isVar(X), has(C,"--")       |-     conjAfter(C, --X),     (Belief:DeductionPN, Time:BeliefEvent)
      C, X, --isVar(X), has(C,"--")     |-     conjAfter(C, --X),       (Goal:DeductionPN, Time:TaskEvent)

    D, X, --isVar(X)                    |-   --conjAfter(D,   X),     (Belief:DeductionNP, Time:BeliefEvent)
      D, X, --isVar(X)                  |-   --conjAfter(D,   X),       (Goal:DeductionNP, Time:TaskEvent)
    D, X, --isVar(X), has(D,"--")       |-   --conjAfter(D, --X),     (Belief:DeductionNN, Time:BeliefEvent)
      D, X, --isVar(X), has(D,"--")     |-   --conjAfter(D, --X),       (Goal:DeductionNN, Time:TaskEvent)

    //desire for sub-sequence leading to goal,  truth function may be Desire or Deduction
    G, C                    |-    conjBefore(C,   G),  (Goal:DesirePP, Time:TaskEvent)
    G, C, has(C,"--")       |-    conjBefore(C, --G),  (Goal:DesireNP, Time:TaskEvent)
        G, D                |-  --conjBefore(D,   G),  (Goal:DesirePN, Time:TaskEvent)
        G, D, has(D,"--")   |-  --conjBefore(D, --G),  (Goal:DesireNN, Time:TaskEvent)

//// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
//If S is the case, and (&&,S,A..+) is not the case, it can't be that (&&,A..+) is the case


//     X, C                             |-   --conjBefore(C,  X),   (Belief:DeductionPN, Time:TaskEvent)
//     X, C                             |-   --conjBefore(C,  --X), (Belief:DeductionNN, Time:TaskEvent)
//     X, D                             |-   --conjBefore(D,  --X),   (Belief:DeductionNN, Time:TaskEvent)
//     X, D                             |-   --conjBefore(D,  X), (Belief:DeductionPN, Time:TaskEvent)

//     C, X, --isVar(X)                            |-   conjBefore(C,  X), (Belief:DeductionPP, Time:BeliefEvent)
//       C, X, conjSequence(C), --isVar(X)     |-   conjAfter(C,  X), (Belief:DeductionPP, Time:BeliefEvent)
//     C, X, --isVar(X)                     |-   conjBefore(C,--X), (Belief:DeductionPN, Time:BeliefEvent)
//       C, X, conjSequence(C), --isVar(X)  |-   conjAfter(C,--X), (Belief:DeductionPN, Time:BeliefEvent)

//         C, X, --isVar(X)                        |-   --conjBefore(C,  X), (Belief:DeductionPN, Time:BeliefEvent)
//           C, X, conjSequence(C), --isVar(X)     |-   --conjAfter(C,  X), (Belief:DeductionPN, Time:BeliefEvent)
//         C, X, --isVar(X)                     |-   --conjBefore(C,--X), (Belief:DeductionPP, Time:BeliefEvent)
//           C, X, conjSequence(C), --isVar(X)  |-   --conjAfter(C,--X), (Belief:DeductionPP, Time:BeliefEvent)

//      D, X, --isVar(X)                        |-  --conjBefore(D, X), (Belief:DeductionNN, Time:BeliefEvent)
//        D, X, conjSequence(D), --isVar(X)     |-   --conjAfter(D, X), (Belief:DeductionNN, Time:BeliefEvent)
//      D, X, --isVar(X)                     |-   --conjBefore(D,--X), (Belief:DeductionNP, Time:BeliefEvent)
//        D, X, conjSequence(D), --isVar(X)  |-   --conjAfter(D,--X), (Belief:DeductionNP, Time:BeliefEvent)
//     D, X, --isVar(X)                     |-   conjBefore(D, X), (Belief:DeductionNP, Time:BeliefEvent)
//       D, X, conjSequence(D), --isVar(X)  |-    conjAfter(D, X), (Belief:DeductionNP, Time:BeliefEvent)
//     D, X, --isVar(X)                        |-     conjBefore(D,--X), (Belief:DeductionNN, Time:BeliefEvent)
//       D, X, conjSequence(D), --isVar(X)     |-      conjAfter(D,--X), (Belief:DeductionNN, Time:BeliefEvent)


//    //conjunction goal decomposition
//    G, C                   |-   conjAfter(C,  G), (Goal:DesirePP)
//      G, D                 |- --conjAfter(D,--G), (Goal:DesirePN)
//    G, C      |-   conjAfter(C,--G), (Goal:DesireWeakNP)
//      G, D                 |- --conjAfter(D,  G), (Goal:DesireWeakNN)

//      (C==>A), (X==>A), --isVar(X)     |- (conjAfter(C,  X) ==> A), (Belief:Deduction)
//      (C==>A), (X==>A), --isVar(X)     |- (conjAfter(C,  X) ==> A), (Belief:DeductionNN)
      //(A==>C), (A==>X), --isVar(X)     |- (A ==> conjAfter(C,  X)), (Belief:Deduction)
      //(A==>C), (A==>X), --isVar(X)     |- (A ==> conjAfter(C,--X)), (Belief:DeductionPN)
      //(A==>C), (A==>X), --isVar(X)     |- (A ==> conjAfter(C,  X)), (Belief:DeductionNN)


    //TODO nal3 shortcut - decompose trailing intersection/union event


//Anonymous Deduction and Abduction
    X, (V ==> X), task("?"), isUnneg(V,"#"), --isVar(X)      |- X, (Belief:BeliefStructuralReduction, Time:TaskEvent)

        X, (X ==> V), task("?"), is(V,"#"), --isVar(X)      |- X,   (Belief:BeliefStructuralAbduction, Time:TaskEvent)
        X, (--X ==> V), task("?"), is(V,"#"), --isVar(X)    |- --X, (Belief:BeliefStructuralAbduction, Time:TaskEvent)



    //TODO test and write predicate version:
      //(C==>Y), X, --isVar(X)         |-  polarizeTask((conjAfter(C,  polarizeBelief(X)) ==> Y)),       (Belief:DeductionDepolarized)
      //(--C==>Y), X, --isVar(X)       |-  polarizeTask(--(conjAfter(C,  --polarizeBelief(X)) ==> Y)),       (Belief:DeductionDepolarized)
     // (--D==>Y), X, --isVar(X) |- polarizeTask((--unisubst(D,chooseUnifiableSubEvent(D,polarizeBelief(X)),polarizeBelief(X),"#") ==> Y)), (Belief:DeductionDepolarized, Goal:DeductionDepolarized)



//Conditional implication decomposition
//  Original:
//    (S ==> M), ((&&,S,A_1..n) ==> M) |- ((&&,A_1..n) ==> M), (Truth:DeductionNegativePositivePositive, Order:ForAllSame, SequenceIntervals:FromBelief)
//    (S ==> M), ((||,S,A_1..n) ==> M) |- ((||,A_1..n) ==> M), (Truth:DeductionPositiveNegativeNegative, Order:ForAllSame)
//    (M ==> S), (M ==> (&&,S,A_1..n)) |- (M ==> (&&,A_1..n)), (Truth:DeductionPositiveNegativeNegative, Order:ForAllSame, SequenceIntervals:FromBelief)
//    (M ==> S), (M ==> (||,S,A_1..n)) |- (M ==> (||,A_1..n)), (Truth:DeductionNegativePositivePositive, Order:ForAllSame)


//    //conj
//    ( C ==> M), (S ==> M), eventOf(C,S)                |-     (  conjWithout(C, S) ==> M), (Belief:DeductionPN, Time:Compose)
//     ( C ==> M), (S ==> M), eventOfNeg(C,S)                |-     (  conjWithout(C, --S) ==> M), (Belief:DeductionPP, Time:Compose)
//    ( C ==> M), (S ==> M), eventOf(C,S)                |-    --(  conjWithout(C, S) ==> M), (Belief:DeductionNN, Time:Compose)
//     ( C ==> M), (S ==> M), eventOfNeg(C,S)                |-    --(  conjWithout(C, --S) ==> M), (Belief:DeductionNP, Time:Compose)
//
//    //disj
//    (  --C ==> M), (S ==> M), eventOf(C,S)          |-   (  --conjWithout(C, S) ==> M), (Belief:DeductionPN, Time:Compose)
//       ( --C ==> M), (S ==> M), eventOf(C,S)        |- --(  --conjWithout(C, S) ==> M), (Belief:DeductionNN, Time:Compose)
//    (  --C ==> M), (S ==> M), eventOfNeg(C,S)          |-   (  --conjWithout(C, --S) ==> M), (Belief:DeductionPP, Time:Compose)
//       ( --C ==> M), (S ==> M), eventOfNeg(C,S)        |- --(  --conjWithout(C, --S) ==> M), (Belief:DeductionNP, Time:Compose)

//conj pred

//   //(M ==> C), (M ==> S), eventOf(C,S), --isVar(M)      |-   (M ==> conjWithout(C,   S)), (Belief:DeductionPP, Time:Compose)
//   (M ==> C), (M ==> S), eventOfNeg(C,S), --isVar(M)   |- --(M ==> conjWithout(C, --S)), (Belief:DeductionPP, Time:Compose)
//   //(M ==> C), (M ==> S), eventOfNeg(C,S), --isVar(M)   |-   (M ==> conjWithout(C, --S)), (Belief:DeductionPN, Time:Compose)
//   (M ==> C), (M ==> S), eventOf(C,S), --isVar(M)      |- --(M ==> conjWithout(C,   S)), (Belief:DeductionPN, Time:Compose)
//       //(M ==> C), (M ==> S), eventOf(C,S), --isVar(M)      |- --(M ==> conjWithout(C,   S)), (Belief:DeductionNP, Time:Compose)
//       (M ==> C), (M ==> S), eventOfNeg(C,S), --isVar(M)   |-   (M ==> conjWithout(C, --S)), (Belief:DeductionNP, Time:Compose)
//       //(M ==> C), (M ==> S), eventOfNeg(C,S), --isVar(M)   |- --(M ==> conjWithout(C, --S)), (Belief:DeductionNN, Time:Compose)
//       (M ==> C), (M ==> S), eventOf(C,S), --isVar(M)      |-   (M ==> conjWithout(C,   S)), (Belief:DeductionNN, Time:Compose)


   (M ==> C), (M ==> S), eventOf(C,S)                 |-   (M ==> conjWithout(C,   S)), (Belief:DeductionPP, Time:Compose)
     //(M ==> S), (M ==> C), eventOf(C,S)                 |-   (M ==> conjWithout(C,   S)), (Belief:DeductionPP, Time:TaskEvent)
   (M ==> C), (M ==> S), eventOfNeg(C,S)              |-   (M ==> conjWithout(C, --S)), (Belief:DeductionPN, Time:Compose)
     //(M ==> S), (M ==> C), eventOfNeg(C,S)              |-   (M ==> conjWithout(C, --S)), (Belief:DeductionNP, Time:TaskEvent)

   (M ==> D), (M ==> S), eventOfNeg(D,S)               |- --(M ==> conjWithout(D, --S)), (Belief:DeductionNN, Time:Compose)
    //(M ==> S), (M ==> D), eventOfNeg(D,S)               |- --(M ==> conjWithout(D, --S)), (Belief:DeductionNN, Time:TaskEvent)
   (M ==> D), (M ==> S), eventOf(D,S)                  |- --(M ==> conjWithout(D,   S)), (Belief:DeductionNP, Time:Compose)
    //(M ==> S), (M ==> D), eventOf(D,S)                  |- --(M ==> conjWithout(D,   S)), (Belief:DeductionPN, Time:TaskEvent)




//    Y, (&&,X,A..+)                  |- unisubst((&&,  X,A..+),X,Y,"#",novel), (Belief:Deduction)
//    Y, (&&,--X,A..+)                |- unisubst((&&,--X,A..+),X,Y,"#",novel), (Belief:DeductionN)
//        Y, (&&,X,A..+), task("?")       |- unisubst((&&,  X,A..+),X,Y,"#",novel), (Punctuation:Question)
//        Y, (&&,--X,A..+), task("?")     |- unisubst((&&,--X,A..+),X,Y,"#",novel), (Punctuation:Question)
//        Y, (&&,X,A..+), task("@")       |- unisubst((&&,  X,A..+),X,Y,"#",novel), (Punctuation:Quest)
//        Y, (&&,--X,A..+), task("@")     |- unisubst((&&,--X,A..+),X,Y,"#",novel), (Punctuation:Quest)


          //Disjunction structural decompose: D = (||,a,b,..) = --(&&,--a, --b, ..)
          //   disabled: may be spam-like
            //D, X,conjParallel(D),  eventOfNeg(D,X)  |- --conjWithout(D,--X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)
            //D, X,conjParallel(D),  eventOf(D,X)     |- --conjWithout(D,X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)

    //D, X, --is(X,"#"),                     eventOf(D,X)     |- --X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),conjParallel(D), eventOf(D,X)     |- --X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventPos)
    //D, X, --is(X,"#"),                     eventOfNeg(D,X)  |-   X,  (Belief:StructuralDeductionWeakN, Time:TaskSubEventNeg)
    //D, X, --is(X,"#"),conjParallel(D), eventOfNeg(D,X)  |-   X,  (  Goal:StructuralDeductionWeakN, Time:TaskSubEventNeg)

//    //specific deduction
//    C, X, eventOf(C,X)           |-   conjWithout(C,  X), (Belief:DeductionPP)
//    C, X, eventOfNeg(C,X)        |-   conjWithout(C,--X), (Belief:DeductionPN)
    //disjunction select
//    D, X, eventOfNeg(D,X), conjParallel(D)            |-   X, (Goal:StructuralDeductionWeakN)
//    D, X, eventOf(D,X), conjParallel(D)               |- --X, (Goal:StructuralDeductionWeakN)

//    D, X, eventOfNeg(D,X), conjParallel(D)            |-   X, (Belief:StructuralDeductionN, Goal:StructuralDeductionN)
//    D, X, eventOf(D,X), conjParallel(D)               |- --X, (Belief:StructuralDeductionN, Goal:StructuralDeductionN)
        //D, X, eventOfPN(D,X)                            |- --conjWithoutPN(D,X), (Belief:StructuralDeductionWeakN, Goal:StructuralDeductionWeakN)
        //D, X, eventOfPN(D,X)                            |- --conjWithoutPN(D,X), (Belief:StructuralDeductionN, Goal:StructuralDeductionN)
        //D, X, eventOfPN(D,X)                            |-   conjWithoutPN(D,X), (Belief:StructuralDeductionWeak, Goal:StructuralDeductionWeak)

    //implication short-circuit doubt TODO
//    (--C==>Y), X, eventOf(C,X)    |- --(Y && C), (Belief:IntersectionPN)
//    (Y==>C), X, eventOf(C,X)    |- --(Y && C), (Belief:IntersectionPN)
//    (Y==>C), X, eventOfNeg(C,X) |-   (Y==>C), (Belief:IntersectionPP)

