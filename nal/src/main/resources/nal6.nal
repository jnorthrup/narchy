

// Conditional syllogism && Independent Variable Elimination
//      If after M, P usually happens, and M happens, it means P is expected to happen

     B, (X ==> A), --is(X,"#"), --is(B,"==>") |- unisubst(X,A,B,"$"), (Belief:PostWeak, Goal:Post, Time:TaskEvent)


     B, (  X ==> C), --is(X,"--"), --is(C,"#"), --is(B,"==>")       |-   unisubst(C,X,B,"$"),  (Belief:DeductionPP, Goal:DeductionWeakPP, Time:TaskEvent)
         B, (  X ==> C), --is(X,"--"), --is(C,"#"), --is(B,"==>")   |-   --unisubst(C,X,B,"$"),  (Belief:DeductionPN, Goal:DeductionWeakPN, Time:TaskEvent)
       B, (--X ==> C), --is(C,"#"), --is(B,"==>")                   |-   unisubst(C,X,B,"$"),  (Belief:DeductionNP, Goal:DeductionWeakNP, Time:TaskEvent)
           B, (--X ==> C), --is(C,"#"), --is(B,"==>")               |-   --unisubst(C,X,B,"$"),  (Belief:DeductionNN, Goal:DeductionWeakNN, Time:TaskEvent)

       //questions
          B, (A ==> C), task("?@"), --is(A,{"--","#"}), --is(C,"#"), --is(B,"==>") |- unisubst((A ==> C),A,B,"$",novel), (Punctuation:Question, Time:TaskEvent)
          B, (--A ==> C), task("?@"), --is(A,"#"),--is(C,"#"), --is(B,"==>") |- unisubst((--A ==> C),A,B,"$",novel), (Punctuation:Question, Time:TaskEvent)

    //impl unify total transform (without decompose)
    B, (X ==> A), --is(X,"#"), --is(B,"==>"), is(A,"&&") |-   polarizeBelief(unisubst((X==>A),chooseUnifiableSubEvent(A,polarizeTask(B)),polarizeTask(B),novel)), (Belief:DeductionDD, Time:TaskEvent)
    B, (A ==> X), --is(X,"#"), --is(B,"==>"), is(A,"&&") |-   polarizeBelief(unisubst((A==>X),chooseUnifiableSubEvent(A,polarizeTask(B)),polarizeTask(B),novel)), (Belief:DeductionDD, Time:TaskEvent)
      B, (--A ==> X), --is(X,"#"), --is(B,"==>"), is(A,"&&") |-   polarizeBelief(unisubst((--A==>X),chooseUnifiableSubEvent(A,polarizeTask(B)),polarizeTask(B),novel)), (Belief:DeductionDD, Time:TaskEvent)


        //antigoal:
        //B, (C ==> A), --is(A,"#"),--is(C,"#"), --is(B,"==>") |- --unisubst(C,A,B), (Goal:PostStrongPN, Time:TaskMinusBeliefDT)

        //questions
          B, (C ==> A), task("?@"), --is(A,"#"),--is(C,"#"), --is(B,"==>") |- unisubst((C ==> A),A,B,"$",novel), (Punctuation:Question, Time:TaskEvent)
          //B, (C ==> A), task("?@"), --is(A,"#"),--is(C,"#"), --is(B,"==>") |- unisubst(C,A,B,"$"), (Time:TaskEvent)


       //second layer
       B, ((&&,C,A..+) ==> X), neq(B,C)       |-   unisubst((&&,polarizeBelief(X),A..+),C,  polarizeTask(B),novel), (Belief:DeductionDD)


//            //--is(A,"#"),
//       B, (  (&&,  C,A..+) ==> X)       |-   unisubst((&&,X,A..+),C,B), (Belief:Abduction)
//       B, (  (&&,--C,A..+) ==> X)       |-   unisubst((&&,X,A..+),C,B), (Belief:AbductionN)
//       B, (--(&&,  C,A..+) ==> X)       |- --unisubst((&&,X,A..+),C,B), (Belief:Abduction)
//       B, (--(&&,--C,A..+) ==> X)       |- --unisubst((&&,X,A..+),C,B), (Belief:AbductionN)


        //TODO more question variations
//        Y, (  C ==> Z), is(C,"&&"),eventOf(C,Y)    |- (  conjWithout(C,  Y) ==> Z), (Belief:Pre)
//        Y, (--C ==> Z), is(C,"&&"),eventOf(C,Y)    |- (--conjWithout(C,  Y) ==> Z), (Belief:Pre)
//        Y, (  C ==> Z), is(C,"&&"),eventOfNeg(C,Y)    |- (  conjWithout(C,--Y) ==> Z), (Belief:PreN)
//        Y, (--C ==> Z), is(C,"&&"),eventOfNeg(C,Y)    |- (--conjWithout(C,--Y) ==> Z), (Belief:PreN)
                //TODO eventsOf
        //Y, (  C ==> Z), isUnneg(C,"&&") |- unisubst((C ==> Z), chooseUnifiableSubEvent(C,Y),Y,novel), (Belief:Pre)
        //Y, (  C ==> Z), isUnneg(C,"&&") |- unisubst((C ==> Z), chooseUnifiableSubEvent(C,--Y),--Y,novel), (Belief:PreN)
          //Y, ((&&,X,A..+) ==> Z), neq(X,Y) |- unisubst(((&&,X,A..+) ==> Z), X,Y,novel), (Belief:Deduction)
           //Y, ((&&,X,A..+) ==> Z) |- unisubst(((&&,X,Y,A..+) ==> Z), X,Y), (Belief:Deduction)

          //Y, ((&&,--X,A..+) ==> Z), neq(X,Y) |- unisubst(((&&,--X,A..+) ==> Z), X,Y,novel), (Belief:DeductionN)
           //Y, ((&&,--X,A..+) ==> Z) |- unisubst(((&&,--X,--Y,A..+) ==> Z), X,Y), (Belief:DeductionN)
                //Y, (--(&&,X,A..+) ==> Z), neq(X,Y) |- unisubst((--(&&,X,A..+) ==> Z), X,Y,novel), (Belief:Deduction)
                 //Y, (--(&&,X,A..+) ==> Z) |- unisubst((--(&&,X,Y,A..+) ==> Z), X,Y), (Belief:Deduction)
                //Y, (--(&&,--X,A..+) ==> Z), neq(X,Y) |- unisubst((--(&&,--X,A..+) ==> Z), X,Y,novel), (Belief:DeductionN)
                 //Y, (--(&&,--X,A..+) ==> Z) |- unisubst((--(&&,--X,--Y,A..+) ==> Z), X,Y), (Belief:DeductionN)




//        (Z ==> C), Y, is(C,"&&"),eventOf(C,Y)                 |- (Z ==> conjWithout(C,    Y)), (Belief:Induction, Time:Task)
//        (Z ==> C), Y, is(C,"&&"),eventOfNeg(C,Y)              |- (Z ==> conjWithout(C,  --Y)), (Belief:InductionPN, Time:Task)
//        (Z ==> C), Y, is(C,"&&")                              |- unisubst((Z ==> C),chooseUnifiableSubEvent(C,Y),Y,novel), (Belief:Induction, Time:Task)
//        (Z ==> C), Y, is(C,"&&"),has(C,"--")                  |- unisubst((Z ==> C),chooseUnifiableSubEvent(C,--Y),--Y,novel), (Belief:InductionPN, Time:Task)
          //Y, (Z ==> (&&,X,A..+)), neq(X,Y),neq(Y,Z) |- unisubst((Z ==> (&&,X,A..+)), X,Y,novel), (Belief:Abduction)
            //Y, (Z ==> (&&,X,A..+)) |- unisubst((Z ==> (&&,X,Y,A..+)), X,Y), (Belief:Abduction)
          //Y, (Z ==> (&&,--X,A..+)), neq(X,Y),neq(Y,Z) |- unisubst((Z ==> (&&,--X,A..+)), X,Y,novel), (Belief:AbductionN)
            //Y, (Z ==> (&&,--X,A..+)) |- unisubst((Z ==> (&&,--X,--Y,A..+)), X,Y), (Belief:AbductionN)




//// implication-based syllogism ////////////////////////////////////////////////////////////////////////////////////
//       (A ==> B) ------- (B ==> C)
//            \               /
//             \             /
//              \           /
//               \         /
//                (A ==> C)

    //"Please note that the temporal order in the conclusion of a weak rule is
    //not necessarily the same as the order in the premises, given the hypothetical
    //nature of such a rule."

    //If after S M happens, and after M then P happens, so S then P happens

//DEDUCTION ----
    (S ==> M),   (M ==> P)    |-     (S ==> P),   (Belief:DeductionPP, Time:Compose)
      (M ==> P), (S ==> M)      |-   (S ==> P),   (Belief:DeductionPP, Time:Compose)
            (S ==> P), (M ==> P), task("?")   |- (S ==> M), (Punctuation:Question, Time:Task)
            (S ==> P), (S ==> M), task("?")   |- (M ==> P), (Punctuation:Question, Time:Task)

    (S ==> M),   (M ==> P)    |-   --(S ==> P), (Belief:DeductionPN, Time:Compose)
      (S ==> M),   (M ==> P)    |-   (S ==> --P), (Belief:DeductionNP, Time:Compose)

    (S ==> M), (--M ==> P)    |-     (S ==> P),   (Belief:DeductionNP, Time:Compose)
      (--M ==> P), (S ==> M)    |-   (S ==> P),     (Belief:DeductionPN, Time:Compose)
            (S ==> P), (--M ==> P), task("?") |- (S ==> M), (Punctuation:Question, Time:Task)
            (S ==> P), (S ==> M), task("?")   |- (--M ==> P), (Punctuation:Question, Time:Task)

    (S ==> M), (--M ==> P)    |-   --(S ==> P), (Belief:DeductionNN, Time:Compose)
      (--M ==> P), (S ==> M)    |-   (S ==> --P),   (Belief:DeductionNN, Time:Compose)

//EXEMPLIFICATION
    (  M ==> S), (P ==> M)       |- (  S ==> P), (Belief:ExemplificationPP, Time:Compose)
      (P ==> M), (  M ==> S)     |- (  S ==> P), (Belief:ExemplificationPP, Time:Compose)
            (S ==> P), (M ==> S), task("?")   |- (P ==> M), (Punctuation:Question, Time:Task)
            (S ==> P), (P ==> M), task("?")   |- (M ==> S), (Punctuation:Question, Time:Task)

    (  M ==> S), (P ==> M)       |- (--S ==> P), (Belief:ExemplificationNP, Time:Compose)
      (P ==> M), (M ==> S)       |- (--S ==> P), (Belief:ExemplificationNP, Time:Compose)

    (--M ==> S), (P ==> M)       |- (  S ==> P), (Belief:ExemplificationPN, Time:Compose)
      (P ==> M), (--M ==> S)     |- (  S ==> P), (Belief:ExemplificationPN, Time:Compose)
            (S ==> P), (--M ==> S), task("?")   |- (P ==> M), (Punctuation:Question, Time:Task)
            (S ==> P), (P ==> M), task("?")   |- (--M ==> S), (Punctuation:Question, Time:Task)

    (--M ==> S), (P ==> M)       |- (--S ==> P), (Belief:ExemplificationNN, Time:Compose)
      (P ==> M), (--M ==> S)     |- (--S ==> P), (Belief:ExemplificationNN, Time:Compose)

//INDUCTION/ABDUCTION

    (M ==> S), (M ==> P) |- (S ==> P), (Belief:Abduction, Time:Compose)
        (M ==> S), (M ==> P) |- (--S ==> --P), (Belief:AbductionNN, Time:Compose)
            (S ==> P), (M ==> P), task("?")   |- (M ==> S), (Punctuation:Question, Time:Task)
            (S ==> P), (M ==> S), task("?")   |- (M ==> P), (Punctuation:Question, Time:Task)
            (--S ==> P), (M ==> P), task("?")   |- (M ==> S), (Punctuation:Question, Time:Task)
            (--S ==> P), (M ==> S), task("?")   |- (M ==> P), (Punctuation:Question, Time:Task)

    (M ==> P), (M ==> S) |- (S ==> P), (Belief:Induction, Time:Compose)
        (M ==> P), (M ==> S) |- (--S ==> --P), (Belief:InductionNN, Time:Compose)

    (S ==> M), (P ==> M) |- (S ==> P), (Belief:InductionPB, Time:Compose)
            (S ==> P), (P ==> M), task("?")   |- (S ==> M), (Punctuation:Question, Time:Task)
            (S ==> P), (S ==> M), task("?")   |- (P ==> M), (Punctuation:Question, Time:Task)

    (S ==> M), (P ==> M) |- (P ==> S), (Belief:AbductionPB, Time:Compose)
            (P ==> S), (P ==> M), task("?")   |- (S ==> M), (Punctuation:Question, Time:Task)
            (P ==> S), (S ==> M), task("?")   |- (P ==> M), (Punctuation:Question, Time:Task)





    //the comparison rules here emulates what Comparison did in generating <=> which are modeled here as a pair of opposing ==>
    //untested
//    (P ==> M), (S ==> M) |- --((S ==> P) && (P ==> S)), (Belief:ComparisonSymmetric)
//    (M ==> P), (M ==> S) |- --((S ==> P) && (P ==> S)), (Belief:ComparisonSymmetric)
////    (P ==> M), (S ==> M) |- (S ==> P), (Belief:Comparison)
////        (P ==> M), (S ==> M) |- (P ==> S), (Belief:Comparison)
////    (M ==> P), (M ==> S) |- (S ==> P), (Belief:Comparison)
////        (M ==> P), (M ==> S) |- (P ==> S), (Belief:Comparison)










//// implication-based composition ////////////////////////////////////////////////////////////////////////////////////
//note: the question variations of these are responsible for creating terms that can be truthed dynamically. so they are important
//Same as for inheritance
//classically: union/intersection assymmetry: union if subj, intersect if pred
//TODO: ...Also:VarIntro)

    //TODO DynamicImplTruth
    //(P ==> M), (S ==> M)  |- ((P && S) ==> M), (Belief:IntersectionPB)
       //(P ==> M), (S ==> M)  |- ((P || S) ==> M), (Belief:UnionPB)

        (P ==> M), (S ==> M)  |- ((P && S) ==> M), (Punctuation:AskAll, Time:Compose)
          //(P ==> M), (S ==> M)  |- ((P || S) ==> M), (Punctuation:AskAll, Time:Compose)
            //(P ==> M), (S ==> M), task("?")  |- (P || S), (Punctuation:Question)
            //(P ==> M), (S ==> M), task("?")  |- (P && S), (Punctuation:Question)


    //TODO DynamicImplTruth

     (M ==> P), (M ==> S)  |- (M ==> (polarizeTask(P) && polarizeBelief(S))), (Punctuation:AskAll, Time:Compose)
       //(M ==> P), (M ==> S)  |- (M ==> (polarizeTask(P) || polarizeBelief(S))), (Punctuation:AskAll, Time:Compose)

//     (M ==> P), (M ==> S)  |- (M ==> (polarizeTask(P) && polarizeBelief(S))), (Belief:IntersectionDD, Time:Compose)
//       (M ==> P), (M ==> S)  |- (M ==> (polarizeTask(P) || polarizeBelief(S))), (Belief:UnionDD, Time:Compose)

//        (M ==> P), (M ==> S), task("?"), hasBelief() |- (M ==> (polarizeRandom(P) && polarizeBelief(S))), (Punctuation:Question, Time:Compose)



        //TODO question variations
        //((&&,P,A..+) ==> X), ((&&,S,A..+) ==> X), neq(P,S) |- ((&&,(P && S),A..+) ==> X), (Belief:IntersectionSym)
        //((&&,P,A..+) ==> X), ((&&,S,A..+) ==> X), neq(P,S) |- ((&&,(P || S),A..+) ==> X), (Belief:UnionSym)

        //TODO question variations
        //(--(&&,P,A..+) ==> X), (--(&&,S,A..+) ==> X), neq(P,S) |- (--(&&,(P && S),A..+) ==> X), (Belief:IntersectionSym)
        //(--(&&,P,A..+) ==> X), (--(&&,S,A..+) ==> X), neq(P,S) |- (--(&&,(P || S),A..+) ==> X), (Belief:UnionSym)



//            B, ((&&,C,A..+) ==> X), neq(B,C) |- unisubst(((&&,A..+) ==> X),C,B), (Belief:Deduction)
//            B, ((&&,--C,A..+) ==> X), neq(B,C) |- unisubst(((&&,A..+) ==> X),C,B), (Belief:DeductionN)
//                B, (--(&&,C,A..+) ==> X), neq(B,C), notImpl(B) |- (--,unisubst(((&&,A..+) ==> X),C,B)), (Belief:Deduction)
//                B, (--(&&,--C,A..+) ==> X), neq(B,C), notImpl(B) |- (--,unisubst(((&&,A..+) ==> X),C,B)), (Belief:DeductionN)

            //(Y --> P), ((&&,(X-->P),A..+) ==> Z),neq(X,Y) |- unisubst(((&&,(X-->P),A..+) ==> Z), X,Y,novel), (Belief:Deduction)
              //  (Y --> P), ((&&,--(X-->P),A..+) ==> Z),neq(X,Y) |- unisubst(((&&,--(X-->P),A..+) ==> Z), X,Y,novel), (Belief:DeductionN)
            //(Y --> P), (Z ==> (&&,(X-->P),A..+)),neq(X,Y) |- unisubst((Z ==> (&&,(X-->P),A..+)), X,Y,novel), (Belief:Deduction)
              //  (Y --> P), (Z ==> (&&,--(X-->P),A..+)),neq(X,Y) |- unisubst((Z ==> (&&,--(X-->P),A..+)), X,Y,novel), (Belief:DeductionN)


    //Conj/Impl Chain Deduction
    (X ==> Y), (C ==> Z), eventOf(C,Y)      |-   ((X && conjWithout(C,  Y)) ==> Z), (Belief:DeductionPP, Time:Compose)
      (X ==> Y), (C ==> Z), eventOf(C,Y)    |- --((X && conjWithout(C,  Y)) ==> Z), (Belief:DeductionPN, Time:Compose)
    (X ==> Y), (C ==> Z), eventOfNeg(C,Y)   |-   ((X && conjWithout(C,--Y)) ==> Z), (Belief:DeductionNP, Time:Compose)
      (X ==> Y), (C ==> Z), eventOfNeg(C,Y) |- --((X && conjWithout(C,--Y)) ==> Z), (Belief:DeductionNN, Time:Compose)

    //Disj/Impl Chain Deduction
    (X ==> Y), (--D ==> Z), eventOfNeg(D,Y)     |-   (X ==> Z), (Belief:DeductionPP, Time:Compose)
      (X ==> Y), (--D ==> Z), eventOfNeg(D,Y)   |- --(X ==> Z), (Belief:DeductionPN, Time:Compose)
    (X ==> Y), (--D ==> Z), eventOf(D,Y)        |-   (X ==> Z), (Belief:DeductionNP, Time:Compose)
      (X ==> Y), (--D ==> Z), eventOf(D,Y)      |- --(X ==> Z), (Belief:DeductionNN, Time:Compose)

    //Conj/Impl Chain Swap Deduction
//    //TODO use conj ops
//    ((&&,X,A..+) ==> Z), (Y ==> X)  |- ((&&,Y,A..+) ==> Z), (Belief:Deduction)
//     (Y ==> X), ((&&,X,A..+) ==> Z)   |- ((&&,Y,A..+) ==> Z), (Belief:Deduction)
//        ((&&,--X,A..+) ==> Z), (Y ==> X)  |- ((&&,Y,A..+) ==> Z), (Belief:DeductionPN)
//         (Y ==> X), ((&&,--X,A..+) ==> Z)  |- ((&&,Y,A..+) ==> Z), (Belief:DeductionN)

    //Negate Both Sides (Equivalence emulation):  (x <=> y) |- (--x <=> --y)
    (X==>Y), (Y==>X) |- (--X ==> --Y), (Belief:Intersection, Time:Compose)
    (X==>Y), (Y==>X) |- (--Y ==> --X), (Belief:Intersection, Time:Compose)
      (--X==>Y), (Y==>X) |- (X ==> --Y), (Belief:IntersectionPN, Time:Compose)
      (--X==>Y), (Y==>X) |- (--Y ==> X), (Belief:IntersectionPN, Time:Compose)

    //Primary Inverting Sub-Condition (Equivalence emulation)
//    ((&&,X,A..+) ==> Z), ((&&,--X,A..+) ==> Z)    |- ((X ==> Z) && (--X ==> --Z)), (Belief:IntersectionPN, Time:Compose)
//    ((&&,X,A..+) ==> Z), ((&&,--X,A..+) ==> Z)    |- ((X ==> --Z) && (--X ==> Z)), (Belief:IntersectionNP, Time:Compose)
//       (Z ==> (&&,X,A..+)), (--Z ==> (&&,--X,A..+)) |- ((Z ==> X) && (--Z ==> --X)), (Belief:IntersectionSym, Time:Compose)


    //conditional induction
    ((&&,Y,A..+) ==> X), (Y ==> Z) |- ((&&,  Z,A..+) ==> X), (Belief:InductionPP, Time:Compose)
    ((&&,Y,A..+) ==> X), (Y ==> Z) |- ((&&,--Z,A..+) ==> X), (Belief:InductionPN, Time:Compose)

    ((&&,X,A..+) ==> Z), ((&&,Y,A..+) ==> Z) |- (Y ==> X), (Belief:InductionPB, Time:Compose)
      (--(&&,X,A..+) ==> Z), (--(&&,Y,A..+) ==> Z) |- (Y ==> X), (Belief:InductionPB, Time:Compose)


        //TODO disj

    //Contradiction Neutralize
    (  (&&,Y,A..+) ==> X), (  (&&,Z,A..+) ==> X), eqNeg(Y,Z), --is(X,"#")     |- (  (&&,A..+) ==> X), (Belief:IntersectionPB, Time:Compose)
    (--(&&,Y,A..+) ==> X), (--(&&,Z,A..+) ==> X), eqNeg(Y,Z), --is(X,"#")     |- (--(&&,A..+) ==> X), (Belief:IntersectionPB, Time:Compose)
    (X ==> (&&,Y,A..+)), (X ==> (&&,Z,A..+)), eqNeg(Y,Z), --is(X,"#")     |- (X ==> (&&,A..+)), (Belief:IntersectionPB, Time:Compose)

    //(Y ==> X), (Z ==> X), eqNeg(Y,Z), --is(X,"#")                       |- (#1 ==> X), (Belief:IntersectionPB, Time:Compose)

    //Anti-conditional Abduction via Multi-conditional Syllogism
    (C ==> X), (E ==> Y), neq(C,E)      |-    unisubst(--(C&&E), X, Y), (Belief:DeductionWeakPN, Time:Compose)
    (C ==> X), (E ==> Y), neq(C,E)      |-    unisubst(--(C&&E), X, Y), (Belief:DeductionWeakNP, Time:Compose)

    //(C ==> X), (E ==> Y), eventOf(C,E)      |-    unisubst(--conjWithout(C,E),X,Y), (Belief:AbductionXOR)
        //TODO disj


//        (C ==> Z), (X ==> M), eventOf(C,X) |- ((conjWithout(C,X) &&   M) ==> Z), (Belief:InductionPB)
//        (C ==> Z), (X ==> M), eventOf(C,X) |- ((conjWithout(C,X) && --M) ==> Z), (Belief:InductionPBPN)

//        ((&&,M,X,A..*) ==> C), (Y ==> C) |- unisubst((M ==> C),X,Y), (Belief:AbductionPB)
//        ((&&,M,A..+) ==> X), ((&&,A..+) ==> Y) |- unisubst((M ==> X),X,Y,"$"), (Belief:AbductionPB)
//          (--(&&,M,A..+) ==> X), (--(&&,A..+) ==> Y) |- unisubst((--M ==> X),X,Y,"$"), (Belief:AbductionPB)
//        ((&&,M,A..+) ==> X), ((&&,A..+) ==> Y) |- unisubst((M ==> Y),Y,X,"$"), (Belief:AbductionPB)
//          (--(&&,M,A..+) ==> X), (--(&&,A..+) ==> Y) |- unisubst((--M ==> Y),Y,X,"$"), (Belief:AbductionPB)
//

    //general implication induction
    (A ==> B), X, --eqPN(A,X), --is(X,"==>")  |- polarizeTask(((A && polarizeBelief(X)) ==> B)), (Belief:InductionDD)



//Union induction
    (&&,X,A..+), (&&,--X,A..+)                 |- (&&,A..+), (Belief:Union, Time:Compose)
    (&&,--X,A..+), (&&,X,A..+)                 |- (&&,A..+), (Belief:Union, Time:Compose)

// Mutex induction
    (&&,X,--Y,A..*), (&&,Y,--X,A..*), neq(X,Y)           |- (&&,--(X && Y),A..*), (Belief:IntersectionPB, Time:Compose)
//    (--(&&,X,A..+) ==> Z), C, eventOf(C,X), eventOf(C,Z) |- --(&&,A..+), (Belief:Abduction, Time:Compose)


//    (&&,X,--Y,A..+), (&&,Y,--X,B..+),neq(A..+,B..+)  |- (&&,--((&&,A..+) && (&&,B..+))), (Belief:Intersection)
//
//    (  (&&,X,--Y,A..*)==>Z), (  (&&,Y,--X,A..*)==>Z)     |- (  (&&,--(X && Y),A..*) ==>   Z), (Belief:IntersectionPP)
//    (  (&&,X,--Y,A..*)==>Z), (  (&&,Y,--X,A..*)==>Z)     |- (  (&&,--(X && Y),A..*) ==> --Z), (Belief:IntersectionNN)
//    (--(&&,X,--Y,A..*)==>Z), (--(&&,Y,--X,A..*)==>Z)     |- (--(&&,--(X && Y),A..*) ==>   Z), (Belief:IntersectionPP)
//    (--(&&,X,--Y,A..*)==>Z), (--(&&,Y,--X,A..*)==>Z)     |- (--(&&,--(X && Y),A..*) ==> --Z), (Belief:IntersectionNN)

      (&&,X,--Y,A..*), (&&,Y,--X,A..*),neq(X,Y)               |-  (  X ==> --Y), (Belief:AbductionPB, Time:Compose)
      (&&,X,--Y,A..*), (&&,Y,--X,A..*),neq(X,Y)               |-  (--Y ==>   X), (Belief:InductionPB, Time:Compose)



//// multi-conditional syllogism ////////////////////////////////////////////////////////////////////////////////////
//Inference about the pre/postconditions

//    ((&&,M,A_1..n) ==> C), M, not_implication_or_equivalence(M) |- ((&&,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)
//    ((&&,M,A_1..n) ==> C), ((&&,A_1..n) ==> C) |- M, (Truth:Abduction, Order:ForAllSame)

//conditional deduction/abduction
//   original:   ((&&,M,A_1..n) ==> C), M, not_implication_or_equivalence(M) |- ((&&,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)
//   original:   ((&&,M,A_1..n) ==> C), (A ==> M) |- ((&&,A,A_1..n) ==> C), (Truth:Deduction, Order:ForAllSame)
//   original:   ((&&,M,A_1..n) ==> C), ((&&,A_1..n) ==> C) |- M, (Truth:Abduction, Order:ForAllSame)
//   original:   ((&&,A,A_1..n) ==> C), (A ==> M) |- ((&&,M,A_1..n) ==> C), (Truth:Abduction, Order:ForAllSame)
//   original:   ((&&,A_1..n) =\> C), M, not_implication_or_equivalence(M) |- ((&&,M,A_1..n) =\> C), (Truth:Induction)
//   original:   ((&&,M,A_1..n) ==> C), ((&&,A,A_1..n) ==> C) |- (A ==> M), (Truth:Induction, Order:ForAllSame)

        //((&&,M,A..+) ==> C), M,                  |- ((&&,A..+) ==> C), (Belief:Deduction)

    //(X ==> C), (B ==> M), eventOf(X,M) |- ((conjWithout(X,M) && B) ==> C), (Belief:Deduction)
    //(X ==> C), (B ==> M), eventOfNeg(X,M) |- ((conjWithout(X,--M) && B) ==> C), (Belief:DeductionPN)
        //((&&,M,A..+) ==> C), (B ==> M), neq(B,M) |- ((&&,B,A..+) ==> C), (Belief:Deduction)

                //((&&,M,A..+) ==> Y), ((&&,A..+) ==> Y)          |- M, (Belief:AbductionPB)
                //((&&,M,A) ==> Y),    (A ==> Y)                  |- M, (Belief:AbductionPB)
                    //(--(&&,M,A..+) ==> Y), (--(&&,A..+) ==> Y)  |- M, (Belief:AbductionPB)
                    //(--(&&,M,A) ==> Y),    (--A ==> Y)          |- M, (Belief:AbductionPB)

            //(C ==> (&&,X,A..+)), (C ==> (&&,Y,A..+))   |- (X ==> Y), (Belief:Abduction)
            //(C ==> (&&,X,A..+)), (C ==> (&&,Y,A..+))   |- (Y ==> X), (Belief:Abduction)

        //    ((&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C)   |- (X ==> Y), (Belief:Induction)
        //    ((&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C)   |- (Y ==> X), (Belief:Induction)
        //        (--(&&,X,A..+) ==> C), (--(&&,Y,A..+) ==> C)   |- (X ==> Y), (Belief:Induction)
        //        (--(&&,X,A..+) ==> C), (--(&&,Y,A..+) ==> C)   |- (Y ==> X), (Belief:Induction)
        //        //(--(&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C)  ???
        //        //(--(&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C)  ???







    //Conjunction Anti-Contradiction: ((X&&A)==>C) and ((--X&&A)==>C)  |-  (A==>C), since X or --X doesnt make a difference
    //((&&,X,A..+) ==> C), (D ==> C), eventOfNeg(D,X)  |- ((&&,A..+) ==> C), (Belief:InductionPB)
        //(--(&&,X,A..+) ==> C), (--D ==> C), eventOfNeg(D,X)  |- ((--,(&&,A..+)) ==> C), (Belief:InductionPB)
    //(C ==> (&&,X,A..+)), (C ==> D), eventOfNeg(D,X)  |- (C ==> (&&,A..+)), (Belief:AbductionPB)

//precondition/post-condition combiner inference rule (variable_unification6):




//        <patham9>
//      this rule says:
//        if two different precondition conjunctions, with a common element lead to the same conclusion,
//        it might be that these different preconditions in the specific conjunctions imply each other
//        because the premises can be swapped for this rule and it is still valid
    (A ==> X), (B ==> X), neq(A,B), neq(A,X), neq(B,X) |- (conjWithout(A,B) ==> conjWithout(B,A)), (Belief:InductionPB, Time:Compose)
    (A ==> X), (B ==> X), neq(A,B), neq(A,X), neq(B,X) |- (conjWithout(B,A) ==> conjWithout(A,B)), (Belief:InductionPB, Time:Compose)

        //((&&,X,A..+) ==> C), ((&&,Y,A..+) ==> C)   |- ((X ==> Y) && (Y ==> X)), (Bel4ief:InductionPB)

    (X ==> A), (X ==> B), neq(A,B), neq(A,X), neq(B,X) |- (conjWithout(A,B) ==> conjWithout(B,A)), (Belief:AbductionPB, Time:Compose)
    (X ==> A), (X ==> B), neq(A,B), neq(A,X), neq(B,X) |- (conjWithout(B,A) ==> conjWithout(A,B)), (Belief:AbductionPB, Time:Compose)






//// conjunction decompose AND dependent variable elimination - decomposition with elimination of a variable

        //, Goal:StructuralStrong
           //maybe subOf?
        //C, X, eventOfPN(C,X)  |- conjWithoutPN(C,X), (Belief:StructuralDeduction, Goal:StructuralStrong)
        //C, X, task("!"), eventOfPN(C,X)  |- conjWithoutPN(C,X), (Punctuation:Quest)













     //((&&,X,A..+) && Z), Z |- (X && Z), (Belief:StructuralDeduction, Goal:StructuralDeduction)
     //(Z && (&&,X,A..+)), Z |- (Z && X), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //((&&,X,A..+) && (--,%Z)), Z |- (X && (--,%Z)), (Belief:StructuralDeduction, Goal:StructuralDeduction)
        //((--,%Z) && (&&,X,A..+)), Z |- ((--,%Z) && X), (Belief:StructuralDeduction, Goal:StructuralDeduction)


     //X, (&&,X,A..+),            task("?@") |- (&&,A..+), ()
     //   X, (&&,(--,%X),A..+),   task("?@") |- (&&,A..+), ()
     //B, (A==>B),                task("?@") |- A, ()
     //A, (A==>B),                task("?@") |- B, ()
     //A, ((--,%A)==>B),          task("?@") |- B, ()


     //(&&,X,A..+), X, task("?@") |- (&&,A..+), ()
     //   (&&,(--,%X),A..+), X, task("?@") |- (&&,A..+), ()


     //B, C, belief("&&") |- subIfUnifiesDep(dropAnyEvent(C),X,B), (Belief:AnonymousAnalogy)
                //,Goal:Deduction
                //Goal:Goduction)

///// conjunction decompose
//
//    (&&,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&|,A_1..n), A_1 |- A_1, (Truth:StructuralDeduction, Desire:StructuralStrong)
//    (&/,B,A_1..n), B, task("!") |- (&/,A_1..n), (Truth:Deduction, Desire:Strong, SequenceIntervals:FromPremises)
//
////// propositional decomposition ////////////////////////////////////////////////////////////////////////////////////
////If S is the case, and (&&,S,A_1..n) is not the case, it can't be that (&&,A_1..n) is the case
//
//    S, (&/,S,A_1..n) |- (&/,A_1..n), (Truth:DeductionPositiveNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,S,A_1..n) |- (&|,A_1..n), (Truth:DeductionPositiveNegativeNegative)
//    S, (&&,S,A_1..n) |- (&&,A_1..n), (Truth:DeductionPositiveNegativeNegative)
//    S, (||,S,A_1..n) |- (||,A_1..n), (Truth:DeductionNegativePositivePositive)
//
////Additional for negation: https://groups.google.com/forum/#!topic/open-nars/g-7r0jjq2Vc
//
//    S, (&/,(--,S),A_1..n) |- (&/,A_1..n), (Truth:DeductionNegativeNegativeNegative, SequenceIntervals:FromPremises)
//    S, (&|,(--,S),A_1..n) |- (&|,A_1..n), (Truth:DeductionNegativeNegativeNegative)
//    S, (&&,(--,S),A_1..n) |- (&&,A_1..n), (Truth:DeductionNegativeNegativeNegative)
//    S, (||,(--,S),A_1..n) |- (||,A_1..n), (Truth:DeductionPositivePositivePositive)

////strong unification
//    (Y ==> X), Z, --is(Z,"==>")     |- unisubst(X,Y,Z), (Belief:Deduction)
//    (Y ==> X), Z, --is(Z,"==>")     |- --unisubst(X,Y,Z), (Belief:DeductionNP)
//    (--Y ==> X), Z, --is(Z,"==>")   |- unisubst(X,Y,Z), (Belief:DeductionPN)
//    (--Y ==> X), Z, --is(Z,"==>")   |- --unisubst(X,Y,Z), (Belief:DeductionNN)
//      (Y ==> X), Z, --is(Z,"==>")     |- unisubst(Y,X,Z), (Belief:Abduction)
//      (Y ==> X), Z, --is(Z,"==>")     |- unisubst(Y,X,Z), (Belief:AbductionNN)
//        (Y ==> X), Z, --is(Z,"==>"), task("?") |- unisubst(Y,X,Z), (Punctuation:Question)
//        (Y ==> X), Z, --is(Z,"==>"), task("?") |- unisubst(X,Y,Z), (Punctuation:Question)
//        (--Y ==> X), Z, --is(Z,"==>"), task("?") |- unisubst(X,Y,Z), (Punctuation:Question)
//

//    (X ==> Y), Z, notImpl(Z)     |- unisubst(X,Y,Z), (Belief:AbductionPB)

