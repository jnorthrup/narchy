


((&&,B,A..+) ==> X), (E ==> Y)          |-    unisubst((&&,A..+),(polarizeTask(X) && B),(polarizeBelief(Y) && E)), (Belief:AbductionDepolarized, Time:TaskEvent)

    //Conditional Abduction via Multi-conditional Syllogism
    (C ==> X), (E ==> Y), eventOf(C,E)      |-    conjWithout(C,E), (Belief:AbductionPB, Time:BeliefEvent)
    (C ==> X), (--E ==> Y), eventOfNeg(C,E) |-    conjWithout(C,--E), (Belief:AbductionPB, Time:BeliefEvent)
      //(E ==> Y), (C ==> X), eventOf(C,E)      |-    conjWithout(C,E), (Belief:AbductionPBX)
      //(--E ==> Y), (C ==> X), eventOfNeg(C,E)      |-    conjWithout(C,--E), (Belief:AbductionPBX)

    (C ==> X), (E ==> Y), eventOf(C,E)      |-    unisubst(conjWithout(C,E),X,Y,"$"), (Belief:AbductionPB, Time:BeliefEvent)



//Question Induction

  X, C, eventOfPN(C,X) |- C, (Punctuation:AskAsk, Time:Task)
    //TODO unified conj question

  B, (C ==> X), --isVar(X) |- unisubst(X,C,B), (Punctuation:AskAsk, Time:Task)
    B, (--C ==> X), --isVar(X) |- unisubst(X,C,B), (Punctuation:AskAsk, Time:Task)
  B, (X ==> C), --isVar(X) |- unisubst(X,C,B), (Punctuation:AskAsk, Time:Task)

  (C ==> X), B, neq(B,C), task("."), --isVar(B) |- unisubst((C ==> X),C,B,novel), (Punctuation:Question, Time:Task)
    (C ==> X), B, neq(B,C), task("."), --isVar(B) |- unisubst((--C ==> X),C,B,novel), (Punctuation:Question, Time:Task)
  (X ==> C), B, neq(B,C), task("."), --isVar(B) |- unisubst((X ==> C),C,B,novel), (Punctuation:Question, Time:Task)




////Contraposition to Disjunction
//    (--S ==> P), (--S ==> P) |- (S || P), (Belief:StructuralDeduction)
//    (S ==> N),   (S ==> P)   |- (S || P), (Belief:StructuralDeductionN)


//Anonymous Analogy (NAL5)
//  originally this only unified depvar (dep var elimination)

//TODO merge these ules into one, requires a variation on unisubst that can apply chooseUnifiableSubEvent in 2 ways
C, Y, is(C,"&&"), has(C,"#"), neq(C,Y), --isVar(Y)               |- unisubst(C,chooseUnifiableSubEvent(C,Y),Y,"#",novel), (Belief:AnonymousAnalogy)
C, Y, is(C,"&&"), has(C,"#"), neq(C,Y), --isVar(Y), has(C,"--")  |- unisubst(C,chooseUnifiableSubEvent(C,--Y),--Y,"#",novel), (Belief:AnonymousAnalogyPN)
    //Goal: ?

    //(&&,X,A..+), Y   |- unisubst((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogy)
      //accelerated version requiring no second-level unification and allows the general case unisubst to be 'novel'
      //C, X, eventOf(C,X)    |- conjWithout(C,X), (Belief:AnonymousAnalogy)
    //(&&,--X,A..+), Y   |- unisubst((&&,A..+),X,Y,"#"), (Belief:AnonymousAnalogyPN)
      //accelerated version requiring no second-level unification and allows the general case unisubst to be 'novel'
      //C, X, eventOfNeg(C,X) |- conjWithout(C,--X), (Belief:AnonymousAnalogyPN)


//Hypothesize Subcondition Identity
//      hypothesize that two subconditions which unify actually refer to the same target,
//      eliminating the variable and simplifying the statement

//      ex: ((f(x) && f($1)) ==> g($1))  |-   (f(x) ==> g(x))

    ((&&,X,Y,A..*) ==> Z), X, neq(X,Y), --isVar(X), --isVar(Y)   |- unisubst(((&&,X,Y,A..*) ==> Z),X,Y,novel), (Belief:StructuralReduction)
      ((&&,X,--Y,A..*) ==> Z), X, --isVar(X), --isVar(Y)   |- unisubst(((&&,X,--Y,A..*) ==> Z),X,Y,novel), (Belief:StructuralReduction)
    (Z ==> (&&,X,Y,A..*)), X, neq(X,Y), --isVar(X), --isVar(Y)    |- unisubst((Z ==> (&&,X,Y,A..*)),X,Y,novel), (Belief:StructuralReduction)
      (Z ==> (&&,X,--Y,A..*)), X, --isVar(X), --isVar(Y)    |- unisubst((Z ==> (&&,X,--Y,A..*)),X,Y,novel), (Belief:StructuralReduction)

    (&&,X,Y,A..*), X, neq(X,Y), --isVar(X), --isVar(Y)       |- unisubst((&&,X,Y,A..*),X,Y,novel), (Belief:StructuralDeduction, Goal:StructuralDeduction)
      (&&,X,--Y,A..*), X, --isVar(X), --isVar(Y)   |- unisubst((&&,X,--Y,A..*),X,Y,novel), (Belief:StructuralDeduction, Goal:StructuralDeduction)



//mutex induction from conjunction events
//    (&&,X,--Y,A..*), X, task(".") |- (X ==> --Y), (Belief:StructuralDeduction)

//implication to similarity (equivalence emulation)
//    (P ==> S), (S ==> P), task(".")   |-   (S <-> P),  (Punctuation:Question)
//    (P ==> S), (--S ==> P), task(".") |- (--S <-> P),  (Punctuation:Question)

    //all these are probably wrong:
        //(--P ==> S), (S ==> P),  task("?") |- (--P ==> --S), (Belief:ConversionPN, Punctuation:Belief)
        //(P ==> S), (--S ==> P),  task("?") |- (P ==> --S), (Belief:Conversion, Punctuation:Belief)
        //(P ==> S), (S ==> P),        task("?") |- ((--,%P) ==> S), (Belief:ConversionPN, Punctuation:Belief)
        //(P ==> S), ((--,%S) ==> P),  task("?") |- (--,((--,%P) ==> S)), (Belief:ConversionPN, Punctuation:Belief)

//and the backward inference driven forward inference:


//experimental:
    //([A] <-> {B}), (A <-> B), task("?") |- ([A] <-> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
    //({A} <-> [B]), (A <-> B), task("?") |- ({A} <-> [B]), (Belief:BeliefIdentity, Punctuation:Belief)
    //([A] --> {B}), (A <-> B), task("?") |- ([A] --> {B}), (Belief:BeliefIdentity, Punctuation:Belief)
    //({A} --> [B]), (A <-> B), task("?") |- ({A} --> [B]), (Belief:BeliefIdentity, Punctuation:Belief)


//NAL3:

//TODO these may produce invalid beliefs if the input contains a query variable, this can be filtered before the rule is processed:



//disjunction
   //(&&,--B,A..+), B, task("?") |- (--,((&&,A..+) && --B)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

////composition on both sides of a statement  TODO - quests handling of these
    //((A..+) --> Z), (X --> Y), task("?") |- ((A..+) --> substitute((A..+),X,Y,novel)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //contains(A..+,X),
    //(Z --> (A..+)), (X --> Y), task("?") |- (substitute((A..+),X,Y,novel) --> (A..+)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)

    //((A..+) <-> Z), (X <-> Y), task("?") |- ((A..+) <-> substitute((A..+),X,Y,novel)), (Belief:BeliefStructuralDeduction, Punctuation:Belief)
        //this one needs reviewed, it might need to be subIfUnified, and other problems




////implication of intersection to difference question
//    //TODO implement with only an op comparison (X ==> D) and a swap functor subSwap2(D), it would be simpler to match
//    (X ==> (A&B)), X, task("?")  |- (X ==> (A~B)), (Punctuation:Question)
//    ((A&B) ==> X), X, task("?")  |- ((A~B) ==> X), (Punctuation:Question)
//      (--(A&B) ==> X), X, task("?")  |- (--(A~B) ==> X), (Punctuation:Question)

//    Z, (X==>Y), task("?"), neq(Y,Z) |- unisubst((X ==> Y), Y, Z, "$", novel), (Belief:BeliefStructuralReduction, Punctuation:Belief)
