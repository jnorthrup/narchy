//// inheritance composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:
//The duality of extension and intension in NAL corresponds to the
//  duality of intersection and union in set theory â€” intensional intersection
//  corresponds to extensional union, and extensional intersection corresponds
//  to intensional union.

    (P --> M), (S --> M),               neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (interSect(polarizeTask(P),polarizeBelief(S)) --> M), (Belief:IntersectionDepolarized)
    (P --> M), (S --> M),               neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (unionSect(polarizeTask(P),polarizeBelief(S)) --> M), (Belief:UnionDepolarized)

        (P --> M), (S --> M), task("!"),   neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (interSect(polarizeTask(P),polarizeRandom(S)) --> M), (Punctuation:Quest)
         (P --> M), (S --> M), task("?@"), neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (interSect(P,polarizeRandom(S)) --> M)


    (M --> P), (M --> S),               neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (M --> interSect(polarizeTask(P),polarizeBelief(S))), (Belief:IntersectionDepolarized)
    (M --> P), (M --> S),               neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (M --> unionSect(polarizeTask(P),polarizeBelief(S))), (Belief:UnionDepolarized)
        (M --> P), (M --> S), task("!"),   neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (M --> interSect(polarizeTask(P),polarizeRandom(S))), (Punctuation:Quest)
         (M --> P), (M --> S), task("?@"), neqRCom(S,P), neqRoot(S,P), notSetsOrDifferentSets(S,P) |- (M --> interSect(P,polarizeRandom(S)))


//component invert to question
     (    M -->   I), M, is(I,"&&")  |- (M -->   negateRandomSubterm(I)), (Punctuation:AskAll)
     (    M --> --%I), M, is(%I,"&&")  |- (M --> --negateRandomSubterm(%I)), (Punctuation:AskAll)
     (    I -->   M), M, is(I,"&&")  |- (  negateRandomSubterm(I)-->M),   (Punctuation:AskAll)
     ( --%I -->   M), M, is(%I,"&&")  |- (  negateRandomSubterm(%I)-->M),   (Punctuation:AskAll)


