//// inheritance composition ////////////////////////////////////////////////////////////////////////////////////
//If P and S are in the intension/extension of M, then union/difference and intersection can be built:
//The duality of extension and intension in NAL corresponds to the
//  duality of intersection and union in set theory â€” intensional intersection
//  corresponds to extensional union, and extensional intersection corresponds
//  to intensional union.

    (P --> M), (S --> M),               neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (interSect(polarizeTask(P),polarizeBelief(S), "|") --> M), (Belief:IntersectionDepolarized)
    (P --> M), (S --> M),               neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (unionSect(polarizeTask(P),polarizeBelief(S), "&") --> M), (Belief:UnionDepolarized)

        (P --> M), (S --> M), task("!"),   neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (interSect(polarizeTask(P),polarizeRandom(S), "|") --> M), (Punctuation:Quest)
         (P --> M), (S --> M), task("?@"), neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (interSect(P,polarizeRandom(S), "|") --> M)


    (M --> P), (M --> S),               neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (M --> interSect(polarizeTask(P),polarizeBelief(S), "&")), (Belief:IntersectionDepolarized)
    (M --> P), (M --> S),               neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (M --> unionSect(polarizeTask(P),polarizeBelief(S), "|")), (Belief:UnionDepolarized)
        (M --> P), (M --> S), task("!"),   neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (M --> interSect(polarizeTask(P),polarizeRandom(S), "&")), (Punctuation:Quest)
         (M --> P), (M --> S), task("?@"), neqRCom(S,P), notSetsOrDifferentSets(S,P) |- (M --> interSect(P,polarizeRandom(S), "&"))


//  union of opposites (coincidentia oppositorum)
//    necessary as its own rule if neqRCom is used to exclude common subterms in the composition rules (above)
    ((&,X,Y,A..*) --> M), ((&,--X,Z,A..*) --> M),neq(Y,Z) |- ((&,Y,Z,A..*) --> M), (Belief:Union)
    (M --> (|,X,Y,A..*)), (M --> (|,--X,Z,A..*)),neq(Y,Z) |- (M --> (|,Y,Z,A..*)), (Belief:Union)

//intersection question formation
//    (W --> S), (W --> B), task("?@"), is(S,"|"), neqRCom(S,B) |- (W --> (S | B)), (Time:Intersect)
//    (W --> S), (W --> B), task("?@"), is(S,"&"), neqRCom(S,B) |- (W --> (S & B)), (Time:Intersect)
//    (S --> W), (B --> W), task("?@"), is(S,"&"), neqRCom(S,B) |- ((S & B) --> W), (Time:Intersect)
//    (S --> W), (B --> W), task("?@"), is(S,"|"), neqRCom(S,B) |- ((S | B) --> W), (Time:Intersect)

//    (P --> M), (S --> M), notSetsOrDifferentSets(S,P), neqRCom(S,P) |- ((P ~ S) --> M), (Belief:Difference, Time:Intersect)
//    (P --> M), (S --> M), notSetsOrDifferentSets(S,P), neqRCom(S,P) |- ((S ~ P) --> M), (Belief:DifferenceReverse, Time:Intersect)
//
//    (M --> P), (M --> S), notSetsOrDifferentSets(S,P), neqRCom(S,P) |- (M --> (P - S)), (Belief:Difference, Time:Intersect)
//    (M --> P), (M --> S), notSetsOrDifferentSets(S,P), neqRCom(S,P) |- (M --> (S - P)), (Belief:DifferenceReverse, Time:Intersect)

        //(P --> M), (S --> M), is(P,"+"), is(S,"+") |- (differ(P,S) --> M), (Belief:Difference)
        //((A,B) --> M), ((X,Y) --> M), is(A,"+"), is(B,"+"), is(X,"+"), is(Y,"+") |- ((intersect(A,X),intersect(B,Y)) --> M), (Belief:Intersection)
        //((A,B) --> M), ((X,Y) --> M), is(A,"+"), is(B,"+"), is(X,"+"), is(Y,"+") |- ((union(A,X),union(B,Y)) --> M), (Belief:Union)


//union/intersection belief/goal to diff question/quest
    (W --> (A&B)), A, --isVar(W) |- (W --> (A-B)), (Punctuation:Ask)
     (W --> (A|B)), A, --isVar(W) |- (W --> (A-B)), (Punctuation:Ask)
    ((A|B) --> W), A, --isVar(W) |- ((A~B) --> W), (Punctuation:Ask)
     ((A&B) --> W), A, --isVar(W) |- ((A~B) --> W), (Punctuation:Ask)