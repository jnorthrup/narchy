
    //how goal
    G, G, task("!") |-         (?1 ==> G) , (Punctuation:Question, Time:Task)

    //result of goal
    G, G, task("!") |-          (G ==> ?1), (Punctuation:Question, Time:Task)

    //result of non-goal
    G, G, task("!") |-        (--G ==> ?1), (Punctuation:Question, Time:Task)

//    //is what with goal/non-goal
//    G, G, task("!") |-           (?1 && polarizeRandom(G)), (Punctuation:Question, Time:Task)

    //hypothesize goal cause (bridge from Goal to Belief)
    //G, G, task("!") |- (#X ==> G), (Punctuation:Belief, Belief:StructuralReduction, Time:Task)

    //hypothesize goal consequence (bridge from Goal to Belief)
    //G, G, task("!") |- (polarizeTask(G) ==> #X), (Punctuation:Belief, Belief:StructuralDeductionDepolarized, Time:Task)

//    //hypothesize goal co-occurrence (bridge from Goal to Belief)
//    G, G, task("!") |-   (  polarizeTask(G) && #X), (Punctuation:Belief, Belief:StructuralDeductionDepolarized, Time:Task)
//    G, G, task("!") |- --(--polarizeTask(G) && #X), (Punctuation:Belief, Belief:StructuralDeductionDepolarized, Time:Task)
//    G, G, task("!") |-   (  polarizeTask(G) && #X), (Punctuation:Goal, Goal:StructuralDeductionDepolarized, Time:Task)
//    G, G, task("!") |- --(--polarizeTask(G) && #X), (Punctuation:Goal, Goal:StructuralDeductionDepolarized, Time:Task)

    //sustain goal
    //G, G, task("!") |-         ((  polarizeTask(G) && ?1) ==> G) , (Punctuation:Question)
    //correct goal
    //G, G, task("!") |-         ((--polarizeTask(G) && ?1) ==> G) , (Punctuation:Question)



    //result of achieving/non-achieving goal and current belief
    //G, B, task("!"), hasBelief() |-        ((polarizeRandom(G) && B) ==> ?1), (Punctuation:Question)

    //should what with goal/non-goal
    //G, B, task("!"), neq(G,B), --is(B,"?"), hasBelief() |-    (&&,polarizeTask(G),polarizeBelief(B)), (Punctuation:Quest, Time:Task)

    //bifurcate plan
    G, B, task("@"), neq(G,B), --is(B,"?"), hasBelief()   |-  (polarizeRandom(G) && polarizeBelief(B)), (Punctuation:Quest, Time:Task)

    //implication look-ahead
    (X==>Y), (X==>Y), task("."), --isVar(X), --isVar(Y) |- ((X && polarizeTask(Y)) ==> ?1), (Punctuation:Question, Time:BeliefEvent)

    //implication look-behind
    (X==>Y), (X==>Y), task("."), --isVar(X), --isVar(Y) |- (?1 ==> (  X && polarizeTask(Y))), (Punctuation:Question)


    //sequence possibility quest
    C, X, task("@"), eventOfPN(C,X), hasBelief() |-  (conjWithoutPN(C,X) && ?1), (Punctuation:Quest)

    //rectify goal inversion
    G, (G && --G), task("!"), hasBelief() |- (?X ==> (polarizeTask(G) && polarizeTask(G))) , (Punctuation:Question, Time:BeliefRelative)


    //avoidance TODO
//    G, C, task("!"), eventOf(C,G)    |- (--C ==> ?1), (Punctuation:Question)
//    G, C, task("!"), eventOfNeg(C,G) |- (--C ==> ?1), (Punctuation:Question)


    //conj quest to impl question
    (G && C), B, eqNeg(C,B), task("@"), hasBelief() |-  (polarizeBelief(B) ==> G), (Punctuation:Question, Time:BeliefRelative)
     //(G && B), B, task("@") |-  (G ==> B), (Punctuation:Question)
     //(G && B), B, task("@") |-  (--G ==> B), (Punctuation:Question)

//quest to 'how' impl question
    B, X, task("@"), --is(B,"==>"), neq(X,B), hasBelief() |- (polarizeBelief(X) ==> B), (Punctuation:Question, Time:TaskRelative)
     //B, X, task("@"), --is(B,"==>"), hasBelief() |- (polarizeRandom(B) ==> X), (Punctuation:Question)

//contrasting conjunction to implication
//TODO test
//    (A&&B),      (A && --B)  |- (A ==> B), (Belief:IntersectionPN)
//    (A && --B),  (A && B)    |- (A ==> B), (Belief:IntersectionNP)

//"what is the difference" between what co-occurrs with goal and non-goal
//    (&&,G,X,A..*), (&&,H,Y,B..*), eqNeg(G,H), neq(X,Y), hasBelief()  |- ((polarizeRandom(X) && polarizeRandom(Y)) --> ?1), (Punctuation:Ask)


    //anti-conjunction containing anti-goal
    G, C, eventOfNeg(C,G), --eventOf(C,G), neq(G,C), hasBelief()  |- (  G && negateEvents(conjBefore(C,--G))), (Punctuation:Ask, Time:Task)
    G, C, eventOf(C,G), --eventOfNeg(C,G), neq(G,C), hasBelief()  |- (--G && negateEvents(conjBefore(C,  G))),   (Punctuation:Ask, Time:Task)
//        G, C, eventOfNeg(C,G), --eventOf(C,G), neq(G,C)  |- (  G && negateEvents(conjBefore(C,--G))), (Goal:DeductionWeakPP, Time:TaskEvent)
//        G, C, eventOf(C,G), --eventOfNeg(C,G), neq(G,C)  |- (--G && negateEvents(conjBefore(C,  G))),   (Goal:DeductionWeakNP, Time:TaskEvent)
    G, C, eventOfNeg(C,G), --eventOf(C,G), neq(G,C), hasBelief()  |- (  G && --conjBefore(C,--G)), (Punctuation:Ask, Time:Task)
    G, C, eventOf(C,G), --eventOfNeg(C,G), neq(G,C), hasBelief()  |- (--G && --conjBefore(C,G)),   (Punctuation:Ask, Time:Task)
    //    G, C, eventOfNeg(C,G), --eventOf(C,G), neq(G,C)  |- (  G && --conjBefore(C,--G)), (Goal:DeductionWeakPP, Time:TaskEvent)
    //    G, C, eventOf(C,G), --eventOfNeg(C,G), neq(G,C)  |- (--G && --conjBefore(C,G)),   (Goal:DeductionWeakNP, Time:TaskEvent)

    //conjunction goal induction
//    G, C, eventOf(C,G), --eventOfNeg(C,G), task("!") |- C, (Goal:DeductionWeak, Time:TaskEvent)
//    G, C, eventOfNeg(C,G), --eventOf(C,G), task("!") |- C, (Goal:DeductionWeakN, Time:TaskEvent)

//    //anti-specific deduction: "conjunction contraposition"
//    G, C, eventOfNeg(C,G), --isVar(G)    |-   (  G && negateEvents(conjWithout(C,--G))), (Goal:DeductionWeakPP, Time:TaskEvent)
//    G, C, eventOf(C,G), --isVar(G)       |-   (--G && negateEvents(conjWithout(C,  G))), (Goal:DeductionWeakNP, Time:TaskEvent)

    //anti-desire for sub-sequence leading to anti-goal. truth function may be Desire or Deduction (option: __Weak, __WeakN)
//    G, C, is(C,"&&"), has(C,"--")       |-              --conjBefore(C, --G),  (Goal:DesireWeakPP)
//    G, C, is(C,"&&")                    |-              --conjBefore(C,   G),  (Goal:DesireWeakNP)
      //G, C, is(C,"&&"), has(C,"--")     |-   negateEvents(conjBefore(C, --G)), (Goal:DesireWeak)
      //G, C, is(C,"&&")                  |-   negateEvents(conjBefore(C,   G)), (Goal:DesireWeakN)


//inverted condition question/quest TODO: invertAll(C,X)..
    //C, X, eventOfPN(C,X)   |- invertAll(C,X), (Punctuation:Ask)
        //C, X, eventOfNeg(C,X)  |- substitute(C,--X,X), (Punctuation:Ask)

    //G, (&&,  G,X,A..*), task("!")     |-    ((X && A..*) ==> G),  (Belief:Desire)
    //G, (&&,--G,X,A..*), task("!")     |-  --((X && A..*) ==> G),  (Belief:DesireN)


    //X, C, eventOfPN(C,X), task("!")   |- conjWithoutPN(C,X),   (Punctuation:Quest)

//impl expansion
//    (A ==> B), B, task(".")      |- ((A && ?1) ==> B), (Punctuation:Question)
//    (A ==> B), A, task(".")      |- (polarize(A,belief) ==> (B && ?1)), (Punctuation:Question)
//     (A ==> B), A, task(".")      |- (polarize(A,belief) ==> (--B && ?1)), (Punctuation:Question)
//      (--A ==> B), A, task(".")  |- (--polarize(A,belief) ==> (B && ?1)), (Punctuation:Question)
//       (--A ==> B), A, task(".")  |- (--polarize(A,belief) ==> (--B && ?1)), (Punctuation:Question)

//--

//    X, Y, task("!") |-          (polarize(Y,belief) ==> X), (Punctuation:Question, Time:Relative)
//    X, Y, task("!") |-                           (X ==> Y), (Punctuation:Question, Time:Relative)
//    X, Y, task("!") |-                         (--X ==> Y), (Punctuation:Question, Time:Relative)
//    X, Y, task("!") |-           (X && polarize(Y,belief)), (Punctuation:Quest, Time:Relative)
//    X, Y, task("!") |-         (--X && polarize(Y,belief)), (Punctuation:Quest, Time:Relative)
//
//    X, Y, task("!") |-           (X && polarize(Y,belief)), (Punctuation:Question, Time:Relative)
//    X, Y, task("!") |-           (--X && polarize(Y,belief)), (Punctuation:Question, Time:Relative)
//
////- ---
//    X, Y, task("@") |-          (polarize(Y,belief) ==> X), (Punctuation:Question, Time:Relative)
//    X, Y, task("@") |-                           (X ==> Y), (Punctuation:Question, Time:Relative)
//    X, Y, task("@") |-                         (--X ==> Y), (Punctuation:Question, Time:Relative)
//    X, Y, task("@") |-           (X && polarize(Y,belief)), (Punctuation:Quest, Time:Relative)
//    X, Y, task("@") |-         (--X && polarize(Y,belief)), (Punctuation:Quest, Time:Relative)
//
//    X, Y, task("@") |-           (X && polarize(Y,belief)), (Punctuation:Question, Time:Relative)
//    X, Y, task("@") |-           (--X && polarize(Y,belief)), (Punctuation:Question, Time:Relative)




//curiosity emulation
//G, A, task("!")  |- (polarize(G,task) && polarize(A,belief)), (Goal:DesireWeakDepolarized, Time:Relative, Also:VarIntro)
    //G, A, task("!")  |- (polarize(G,task) && --polarize(A,belief)), (Goal:DesireWeakDepolarized, Time:Relative, Also:VarIntro)
//G, A, task("!")  |- (polarize(G,task) && --polarize(A,belief)), (Punctuation:Quest, Time:Relative, Also:VarIntro)




    //X, (Y==>X), task("!"), neq(X,Y)      |-          Y, (Punctuation:Quest)

    //X, (Y==>X), task("!"), neq(X,Y)      |-          Y, (Punctuation:Question)
    //X, (Y==>X), task("!"), neq(X,Y)      |-          (?1 && Y), (Punctuation:Question)
    //X, (Y==>X), task("!"), neq(X,Y)      |-          (?1 && --Y), (Punctuation:Question)
    //X, (Y==>X), task("!"), neq(X,Y)      |-          (?1 ==> Y), (Punctuation:Question)

    //X, (X==>Y), task("!"), neq(X,Y)         |- Y, (Punctuation:Quest)
    //X, (--X==>Y), task("!"), neq(X,Y)       |- Y, (Punctuation:Quest)
    //X, (X && Y), task("!"), neqUnneg(X,Y)   |- Y, (Punctuation:Quest)
    //X, (--X && Y), task("!"), neqUnneg(X,Y) |- Y, (Punctuation:Quest)

//general impl question induction
    //(X ==> Y), Z, task("?")       |- ((X &&   Z) ==> Y), (Punctuation:Question)
    //(X ==> Y), Z, task("?")       |- ((X && --Z) ==> Y), (Punctuation:Question)


//goal sub-condition preference compare
//   (X-->A), (Y-->A), neqRoot(X,Y), --isVar(X), --isVar(Y), --isVar(A), task("!") |- (((polarizeTask(X) && Y) ~ (polarizeTask(X) && --Y)) --> A), (Punctuation:Quest)
//   (X-->A), (Y-->A), neqRoot(X,Y), --isVar(X), --isVar(Y), --isVar(A), task("!") |- (((polarizeTask(X) && --Y) ~ (polarizeTask(X) && Y)) --> A), (Punctuation:Quest)
//   (A-->X), (A-->Y), neqRoot(X,Y), --isVar(X), --isVar(Y), --isVar(A), task("!") |- (A --> ((polarizeTask(X) && Y) - (polarizeTask(X) && --Y))), (Punctuation:Quest)
//   (A-->X), (A-->Y), neqRoot(X,Y), --isVar(X), --isVar(Y), --isVar(A), task("!") |- (A --> ((polarizeTask(X) && --Y) - (polarizeTask(X) && Y))), (Punctuation:Quest)

//similarity goal comparator TODO bifurcate a similarity to determine which half is more desirable
   //(X<->A), (Y<->A), ...

//what else? impl question <- spammy
    //(A ==> Y), (B ==> Y), task("?") |- (?1 ==> Y), (Punctuation:Question)
    //(X ==> A), (X ==> B), task("?") |- (X ==> ?1), (Punctuation:Question)

    //changing goal context
    //G, Y, task("!") |-         ((G && ?1) ==> (G && ?2)), (Punctuation:Question)
      //G, Y, task("!") |-         ((G || ?1) && (G || ?2)), (Punctuation:Quest)
    //changing non-goal context
    //G, Y, task("!") |-         ((--G && ?1) ==> (--G && ?2)), (Punctuation:Question)
      //G, Y, task("!") |-         ((--G || ?1) && (--G || ?2)), (Punctuation:Quest)

//inheritance to impl question/quest
    //(A-->P), (B-->P)  |- (polarize((A-->P),task) ==> (B-->P)), (Punctuation:Ask)
    //(S-->A), (S-->B)  |- (polarize((S-->A),task) ==> (S-->B)), (Punctuation:Ask)

//goal search
    //(X-->Y), X, task("!") |-          (?1 ==> (X-->Y)), (Punctuation:Question)
    //(X-->Y), X, task("!") |-          ((X-->Y) ==> ?1), (Punctuation:Question)
    //(X-->Y), X, task("!") |-        (--(X-->Y) ==> ?1), (Punctuation:Question)
    //(X-->Y), X, task("!") |-         (?1 && --(X-->Y)), (Punctuation:Question)
