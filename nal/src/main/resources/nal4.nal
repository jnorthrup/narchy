//image structural transform forward


(I --> P), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,X), --has(P,"$") |- imageInt((I-->P),X), (Belief:Identity, Goal:Identity)
(I --> P), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,--X), has(P, "--"), --has(P,"$") |- imageInt((I-->P),--X), (Belief:Identity, Goal:Identity)

//    (I --> P), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,X), task("?@"), --has(P,"$") |- imageInt((I-->P),X)
//    (I --> P), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,--X), has(P, "--"), task("?@"), --has(P,"$") |- imageInt((I-->P),--X)

(P --> I), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,X), --has(P,"$") |- imageExt((P-->I),X), (Belief:Identity, Goal:Identity)
(P --> I), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,--X), has(P, "--"), --has(P,"$") |- imageExt((P-->I),--X), (Belief:Identity, Goal:Identity)

//    (P --> I), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,X), task("?@"), --has(P,"$") |- imageExt((P-->I),X)
//    (P --> I), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,--X), has(P, "--"), task("?@"), --has(P,"$") |- imageExt((P-->I),--X)

//TODO and these arent right yet
//(I --> P), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,X) |- imageInt((I-->substitute(P,X,--X)),--X), (Belief:IdentityN, Goal:IdentityN)
//(P --> I), X, is(P,"*"), --subOf(P,/), --subOf(P,\), subsMin(P,2), subOf(P,X) |- imageExt((substitute(P,X,--X)-->I),--X), (Belief:IdentityN, Goal:IdentityN)


//image structural transform reverse
//(X --> P), (X --> P),                is(P,"*"), subsMin(P,2), subOf(P,/) |- imageNormalize((X-->P)), (Belief:Identity, Goal:Identity)
//    (X --> P), (X --> P), task("?@"), is(P,"*"), subsMin(P,2), subOf(P,/) |- imageNormalize((X-->P))
//(P --> X), (P --> X),                is(P,"*"), subsMin(P,2), subOf(P,\) |- imageNormalize((P-->X)), (Belief:Identity, Goal:Identity)
//    (P --> X), (P --> X), task("?@"), is(P,"*"), subsMin(P,2), subOf(P,\) |- imageNormalize((P-->X))


//1-element product wrap
   ((X)-->(Y)), (X-->Y), task("?") |- polarizeBelief(((X)-->(Y))), (Belief:BeliefStructuralReductionDD, Punctuation:Belief, Time:Task)
     ((X)<->(Y)), (X<->Y), task("?") |- polarizeBelief(((X)<->(Y))), (Belief:BeliefStructuralReductionDD, Punctuation:Belief, Time:Task)
//1-element product unwrap
   (X-->Y), ((X)-->(Y)), task("?") |- polarizeBelief((X-->Y)), (Belief:BeliefStructuralReductionDD, Punctuation:Belief, Time:Task)
     (X<->Y), ((X)<->(Y)), task("?") |- polarizeBelief((X<->Y)), (Belief:BeliefStructuralReductionDD, Punctuation:Belief, Time:Task)

////composition on both sides of a statement
    (A --> B), (X --> Y), subOf(A,X), subOf(B,Y), subsMin(A,2), subsMin(B,2), is(A,"*"), is(B,"*"), task("?") |- polarizeBelief((A --> B)), (Belief:BeliefStructuralReductionDD, Punctuation:Belief)
    (A <-> B), (X <-> Y), subOf(A,X), subOf(B,Y), subsMin(A,2), subsMin(B,2), is(A,"*"), is(B,"*"), task("?") |- polarizeBelief((A <-> B)), (Belief:BeliefStructuralReductionDD, Punctuation:Belief)
    ((X,P) --> Z), (X --> Y), is(Z,"?"), task("?") |- polarizeBelief(((X,P) --> (Y,P))), (Belief:BeliefStructuralReductionDD, Punctuation:Belief)
    (Z --> (X,P)), (Y --> X), is(Z,"?"), task("?") |- polarizeBelief(((Y,P) --> (X,P))), (Belief:BeliefStructuralReductionDD, Punctuation:Belief)

//    ((X,P) --> (Y,P)) , (X --> Y), neq(X,\), neq(Y,\), neq(X,/), neq(Y,/), task("?") |- ((X,P) --> (Y,P)), (Belief:BeliefStructuralReduction, Punctuation:Belief)
//    ((P,X) --> (P,Y)) , (X --> Y), neq(X,\), neq(Y,\), neq(X,/), neq(Y,/), task("?") |- ((P,X) --> (P,Y)), (Belief:BeliefStructuralReduction, Punctuation:Belief)


//
//    ((\,N,A,_) --> ?X), (N --> R), task("?") |- ((\,N,A,_) --> (\,R,A,_)), (Truth:BeliefStructuralDeduction, Punctuation:Judgment)
//    ((\,N,A,_) --> (\,R,A,_)), (N --> R), task("?") |- ((\,N,A,_) --> (\,R,A,_)), (Truth:BeliefStructuralDeduction, Punctuation:Judgment)
//
//    ((/,N,_,B) --> ?X), (S --> B), task("?") |- ((/,N,_,B) --> (/,N,_,S)), (Truth:BeliefStructuralDeduction, Punctuation:Judgment)
//    ((/,N,_,B) --> (/,N,_,S)), (S --> B), task("?") |- ((/,N,_,B) --> (/,N,_,S)), (Truth:BeliefStructuralDeduction, Punctuation:Judgment)
