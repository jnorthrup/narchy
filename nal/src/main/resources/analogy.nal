// General Analogy
//   see:
//      https://en.wikipedia.org/wiki/Fluid_Concepts_and_Creative_Analogies
//      https://cogsci.indiana.edu/

  X, (X<->Y)                        |- Y, (Belief:Analogy, Goal:Goalduction, Time:TaskImmediate)
  X, (X<->Y)                        |- --Y, (Belief:AnalogyN, Goal:GoalductionWeakN, Time:TaskImmediate)
  X, (--X<->Y)                      |- Y, (Belief:AnalogyN, Goal:GoalductionN, Time:TaskImmediate)
  Z, (X <-> Y), in(Z,X), neq(Z,Y)   |- substitute(Z, X, Y, strict), (Belief:Analogy, Goal:Goalduction, Time:TaskImmediate)
  Z, (X <-> Y), neq(Z,X), neq(Z,Y)    |- subIfUnifiesAny(Y, X, Z, strict), (Belief:Analogy, Goal:GoalductionWeak, Time:TaskImmediate)
  Z, (--X <-> Y), neq(Z,X), neq(Z,Y)  |- subIfUnifiesAny(Y, X, Z, strict), (Belief:AnalogyN, Goal:GoalductionWeakN, Time:TaskImmediate)

  (&&,(X<->Y),A..+), (X<->Y)         |- substitute((&&,A..+),X,Y,strict), (Belief:StructuralDeduction, Goal:StructuralStrong, Time:Task)
  //chain:
  (&&,(X<->Y),(Y<->Z),A..+), (X<->Y) |- substitute(substitute((&&,A..+),X,Z,strict),Y,Z,strict), (Belief:StructuralDeduction, Goal:StructuralStrong, Time:Task)

  //((X --> $1) <-> (Y --> $1)), (Y --> A)     |-  subIfUnifiesAny((X-->B),A,B), (Belief:Analogy)

  //Higher-Order Logic Bridge  <a ==> c> <b ==> c>. |- <a <-> b>. %F_cmp%
//  (X ==> Z), (Y ==> Z), neq(X,Y) |- (X<->Y), (Belief:ComparisonSymmetric)

  //(M --> P), (S <-> M), neqRCom(S,P) |- (S --> P), (Belief:Analogy, Goal:Goalduction)
  //(P --> M), (S <-> M), neqRCom(S,P) |- (P --> S), (Belief:Analogy, Goal:Goalduction)

  //wantX and X similar Y then want Y
    //X, (X<->Y)                          |- Y, (Belief:Analogy, Goal:Goalduction)
    //Z, (X<->Y), in(Z,X), neq(Z,X), neq(Z,Y)  |- subIfUnifiesAny(Z, X, Y, strict), (Belief:Analogy, Goal:Weak)

  //notWantX and notX similar Y then want Y

  //want/notWant X,  and not X similar Y then not/want Y
    //X, (X<->Y)                          |- --Y, (Goal:WeakPN)
    //X, (--X<->Y)                        |- --Y, (Goal:WeakNN)


    //Z, (X<->Y), inNeg(Z,X)             |- subIfUnifiesAny(Z, X, Y, strict, force), (Belief:AnalogyN, Goal:WeakN)
    //Z, (X<->Y), neq(Z,X), neq(Z,Y)    |- subIfUnifiesAny(Y, --X, Z, strict), (Belief:AnalogyN, Goal:WeakN)
      //X, (X<->Y)                 |- (--,Y), (Goal:WeakPN)
      //X, (--X<->Y)               |- (--,Y), (Goal:WeakNN)
      //(X-->A), (($1-->A)<->($1-->B)), neqRCom(X,B) |- (X-->B), (Belief:Analogy, Goal:Induction)

//Similarity in Conjunction spreading
 //   (&&,(X<->Y),A..+), (Y<->Z), neqRCom(X,Z) |- (&&,(X<->Z),A..+), (Belief:Analogy, Goal:Weak)
 //   (&&,--(X<->Y),A..+), (Y<->Z), neqRCom(X,Z) |- (&&,--(X<->Z),A..+), (Belief:Analogy, Goal:Weak)
    //TODO (&&,(X<->Y),A..+), (&&,(Y<->Z),A..+), neq(X,Z) |- (&&,(X<->Z),A..+), (Belief:...

 //suspect:
// Z, (X<->Y), eqOrIn(X,Z), belief(negative)   |- (--, subIfUnifiesAny(Z, X, Y, strict, force)), (Belief:AnalogyPN, Goal:WeakPN)
//Z, (--X<->Y), eqOrIn(X,Z), belief(positive) |- subIfUnifiesAny(Z, X, Y, strict, force), (Belief:AnalogyN, Goal:WeakN)
 //Z, (--X<->Y), eqOrIn(X,Z), belief(negative) |- (--, subIfUnifiesAny(Z, X, Y, strict, force)), (Belief:AnalogyNN, Goal:WeakNN)

//these old rules are replaced by the above rules:
        //If M is a special case of P and S and M are similar, then S is also a special case of P (strong)

            //(M --> P), (S <-> M), neqRCom(S,P) |- (S --> P), (Belief:Analogy, Goal:Goalduction)
                    //TODO write test case for this
            //(P --> M), (S <-> M), neqRCom(S,P) |- (P --> S), (Belief:Analogy, Goal:Goalduction)
                    //TODO write test case for this
            //variable elimination 4b:

        //    (X --> A),        ((Y --> A)<->(Y --> C)),  neqRCom(X,C), neq(X,Y)      |- (X-->C), (Belief:Analogy, Goal:Goalduction)
         //       (X --> A),  (--(Y --> A)<->(Y --> C)),  neqRCom(X,C), neq(X,Y)      |- (X-->C), (Belief:AnalogyN, Goal:GoalductionN)
          //  (A --> X),        ((A --> Y)<->(C --> Y)),  neqRCom(X,C), neq(X,Y)      |- (C-->X), (Belief:Analogy, Goal:Goalduction)
          //      (A --> X),  (--(A --> Y)<->(C --> Y)),  neqRCom(X,C), neq(X,Y)      |- (C-->X), (Belief:AnalogyN, Goal:GoalductionN)
